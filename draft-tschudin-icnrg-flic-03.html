<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" 
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html lang="en" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head profile="http://www.w3.org/2006/03/hcard http://dublincore.org/documents/2008/08/04/dc-html/">
  <meta http-equiv="Content-Type" content="text/html; charset=us-ascii" />

  <title>File-Like ICN Collections (FLIC)</title>

  
<style type="text/css">/*<![CDATA[*/

body {
  font: 16px "Helvetica Neue","Open Sans",Helvetica,Calibri,sans-serif;
  color: #333;
  font-size-adjust: 0.5;
  line-height: 24px;
  margin: 75px auto;
  max-width: 624px;
  padding: 0 5px;
}

.title, .filename, h1, h2, h3, h4, h5 {
  font: 16px "Roboto Condensed","Helvetica Neue","Open Sans",Helvetica,Calibri,sans-serif;
  font-size-adjust: 0.5;
  font-weight: bold;
  color: #333;
  line-height: 100%;
  margin: 1.2em 0 0.3em;
}
.title, #rfc\.title h1 { font-size: 32px; }
h1, section h1, h2, section h2, section h3, nav h2 { font-size: 20px; }
h3, section h4, h4, section h5 { font-size: 16px; }
h1 a[href], h2 a[href], h3 a[href], h4 a[href] {
  color: #333;
}

table {
  margin-left: 0em;
  border-collapse: collapse;
}
th {
  text-align: left;
  border-bottom: 2px solid #ddd;
}
td {
  border-top: 1px solid #ddd;
  vertical-align: top;
}
tr:nth-child(2n+1) > td,
tr:nth-child(2n+1) > th {
  background-color: #f9f9f9;
}
td.reference {
  max-width: 200px;
  border-top: none;
  padding-right: 1em;
}
.right {
  text-align: right;
}


table.header, table#rfc\.headerblock {
  width: 100%;
}
table.header td, table#rfc\.headerblock td {
  border: none;
  background-color: transparent;
  color: black;
  padding: 0;
}
.filename {
  display: block;
  color: rgb(119, 119, 119);
  font-size: 20px;
  font-weight: normal;
  line-height: 100%;
  margin: 10px 0 32px;
}
#rfc\.abstract+p, #rfc\.abstract+p code, #rfc\.abstract+p samp, #rfc\.abstract+p tt {
  font-size: 20px;
  line-height: 28px;
}

samp, tt, code, pre, span.tt {
  font-size: 13.5px;
  font-family: Consolas, monospace;
  font-size-adjust: none;
}
pre {
  background-color: #eee;
  border: 1px solid #ddd;
  overflow-x: auto;
  padding: 5px;
  margin: 5px;
}
.figure, caption {
  font-style: italic;
  margin: 0 1.5em;
  text-align: left;
}

address {
  margin: 16px 2px;
  line-height: 20px;
}
.vcard {
  font-style: normal;
}
.vcardline {
  display: block;
}
.vcardline .fn, address b {
  font-weight: normal;
}
.vcardline .hidden {
  display: none;
}

dl {
  margin-left: 1em;
}
dl.dl-horizontal: {
  margin-left: 0;
}
dl > dt {
  float: left;
  margin-right: 1em;
}
dl.nohang > dt {
  float: none;
}
dl > dd {
  margin-bottom: .5em;
}
dl.compact > dd {
  margin-bottom: 0em;
}
dl > dd > dl {
  margin-top: 0.5em;
  margin-bottom: 0em;
}
ul.empty {
  list-style-type: none;
}
ul.empty li {
  margin-top: .5em;
}

hr {
  border: 0;
  border-top: 1px solid #eee;
}
hr.noprint {
  display: none;
}

a {
  text-decoration: none;
}
a[href] {
  color: #2a6496;
}
a[href]:hover {
  background-color: #eee;
}

p, ol, ul, li {
  padding: 0;
}
p {
  margin: 0.5em 0;
}
ol, ul {
  margin: 0.2em 0 0.2em 2em;
}
li {
  margin: 0.2em 0;
}
address {
  font-style: normal;
}

ul.toc ul {
  margin: 0 0 0 2em;
}
ul.toc li {
  list-style: none;
  margin: 0;
}

@media screen and (min-width: 924px) {
  body {
    padding-right: 350px;
  }
  body>ul.toc, body>#rfc\.toc {
    position: fixed;
    bottom: 0;
    right: 0;
    right: calc(50vw - 500px);
    width: 300px;
    z-index: 1;
    overflow: auto;
    overscroll-behavior: contain;
  }
  body>#rfc\.toc {
    top: 55px;
  }
  body>ul.toc {
    top: 100px;
  }

  ul.toc {
    margin: 0 0 0 4px;
    font-size: 12px;
    line-height: 20px;
  }
  ul.toc ul {
    margin-left: 1.2em;
  }
}

.github-fork-ribbon-wrapper {
  display: none;
}
@media screen and (min-width: 800px) {
  /* "Fork me on GitHub" CSS ribbon based on
   * https://github.com/simonwhitaker/github-fork-ribbon-css
   */
  .github-fork-ribbon {
    position: absolute;
    padding: 2px 0;
    background-color: #a00;
    background-image: linear-gradient(to bottom, rgba(0, 0, 0, 0), rgba(0, 0, 0, 0.15));
    box-shadow: 0 2px 3px 0 rgba(0, 0, 0, 0.5);
    font: 700 12px "Helvetica Neue", Helvetica, Arial, sans-serif;

    pointer-events: auto;

    top: 38px;
    right: -45px;

    transform: rotate(45deg);
  }

  .github-fork-ribbon a[href],
  .github-fork-ribbon a[href]:hover {
    color: #fff;
    background-color: transparent;
    text-decoration: none;
    text-shadow: 0 -1px rgba(0, 0, 0, 0.5);
    text-align: center;

    width: 190px;
    line-height: 18px;

    display: inline-block;
    padding: 2px 0;

    border: 1.5px dotted #fff;
    border-color: rgba(255, 255, 255, 0.6);
  }

  .github-fork-ribbon-wrapper {
    display: block;
    width: 130px;
    height: 130px;
    position: absolute;
    overflow: hidden;
    top: 0; right: 0;
    z-index: 2;
    pointer-events: none;
  }
}
@media screen and (min-width: 1000px) {
  .github-fork-ribbon-wrapper {
    position: fixed;
  }
/*]]>*/</style>
<meta name="viewport" content="initial-scale=1.0">


  <link href="#rfc.toc" rel="Contents"/>
<link href="#rfc.section.1" rel="Chapter" title="1 Introduction"/>
<link href="#rfc.section.1.1" rel="Chapter" title="1.1 Requirements Language"/>
<link href="#rfc.section.2" rel="Chapter" title="2 Design Goals"/>
<link href="#rfc.section.3" rel="Chapter" title="3 FLIC Structure"/>
<link href="#rfc.section.3.1" rel="Chapter" title="3.1 Terminology"/>
<link href="#rfc.section.3.2" rel="Chapter" title="3.2 Locators"/>
<link href="#rfc.section.3.3" rel="Chapter" title="3.3 Namespaces"/>
<link href="#rfc.section.3.4" rel="Chapter" title="3.4 Manifest Metadata"/>
<link href="#rfc.section.3.5" rel="Chapter" title="3.5 Pointer Annotations"/>
<link href="#rfc.section.3.6" rel="Chapter" title="3.6 Manifest Grammar (ABNF)"/>
<link href="#rfc.section.3.7" rel="Chapter" title="3.7 Manifest Trees"/>
<link href="#rfc.section.3.7.1" rel="Chapter" title="3.7.1 Traversal"/>
<link href="#rfc.section.3.8" rel="Chapter" title="3.8 Manifest Encryption"/>
<link href="#rfc.section.3.8.1" rel="Chapter" title="3.8.1 Preshared Key Algorithm"/>
<link href="#rfc.section.3.8.2" rel="Chapter" title="3.8.2 RSA Key Encapsulation"/>
<link href="#rfc.section.3.8.3" rel="Chapter" title="3.8.3 ECC Group Keys"/>
<link href="#rfc.section.3.9" rel="Chapter" title="3.9 Protocol Encodings"/>
<link href="#rfc.section.3.9.1" rel="Chapter" title="3.9.1 CCNx Encoding"/>
<link href="#rfc.section.3.9.2" rel="Chapter" title="3.9.2 NDN Encoding"/>
<link href="#rfc.section.3.10" rel="Chapter" title="3.10 Example Structures"/>
<link href="#rfc.section.3.10.1" rel="Chapter" title="3.10.1 Leaf-only data"/>
<link href="#rfc.section.3.10.2" rel="Chapter" title="3.10.2 Linear"/>
<link href="#rfc.section.4" rel="Chapter" title="4 IANA Considerations"/>
<link href="#rfc.section.5" rel="Chapter" title="5 Security Considerations"/>
<link href="#rfc.section.6" rel="Chapter" title="6 Appendix A: Building Trees"/>
<link href="#rfc.references" rel="Chapter" title="7 References"/>
<link href="#rfc.references.1" rel="Chapter" title="7.1 Normative References"/>
<link href="#rfc.references.2" rel="Chapter" title="7.2 Informative References"/>
<link href="#rfc.authors" rel="Chapter"/>


  <meta name="generator" content="xml2rfc version 2.5.2 - http://tools.ietf.org/tools/xml2rfc" />
  <link rel="schema.dct" href="http://purl.org/dc/terms/" />

  <meta name="dct.creator" content="Tschudin, C., Wood, C., and M. Mosko" />
  <meta name="dct.identifier" content="urn:ietf:id:draft-tschudin-icnrg-flic-03" />
  <meta name="dct.issued" scheme="ISO8601" content="2019-9-23" />
  <meta name="dct.abstract" content="This document describes a bare bones &quot;index table&quot;-approach for organizing a set of ICN data objects into a large, File-Like ICN Collection (FLIC).  At the core of this collection is a so called manifest which acts as the collection's root node. The manifest contains an index table with pointers, each pointer being a hash value pointing to either a final data block or another index table node." />
  <meta name="description" content="This document describes a bare bones &quot;index table&quot;-approach for organizing a set of ICN data objects into a large, File-Like ICN Collection (FLIC).  At the core of this collection is a so called manifest which acts as the collection's root node. The manifest contains an index table with pointers, each pointer being a hash value pointing to either a final data block or another index table node." />

</head>

<body>

  <table class="header">
    <tbody>
    
    	<tr>
  <td class="left">ICNRG</td>
  <td class="right">C. Tschudin</td>
</tr>
<tr>
  <td class="left">Internet-Draft</td>
  <td class="right">University of Basel</td>
</tr>
<tr>
  <td class="left">Intended status: Experimental</td>
  <td class="right">C. Wood</td>
</tr>
<tr>
  <td class="left">Expires: March 26, 2020</td>
  <td class="right">University of California Irvine</td>
</tr>
<tr>
  <td class="left"></td>
  <td class="right">M. Mosko</td>
</tr>
<tr>
  <td class="left"></td>
  <td class="right">PARC, Inc.</td>
</tr>
<tr>
  <td class="left"></td>
  <td class="right">September 23, 2019</td>
</tr>

    	
    </tbody>
  </table>

  <p class="title">File-Like ICN Collections (FLIC)<br />
  <span class="filename">draft-tschudin-icnrg-flic-03</span></p>
  
  <h1 id="rfc.abstract">
  <a href="#rfc.abstract">Abstract</a>
</h1>
<p>This document describes a bare bones "index table"-approach for organizing a set of ICN data objects into a large, File-Like ICN Collection (FLIC).  At the core of this collection is a so called manifest which acts as the collection's root node. The manifest contains an index table with pointers, each pointer being a hash value pointing to either a final data block or another index table node.</p>
<h1 id="rfc.status">
  <a href="#rfc.status">Status of This Memo</a>
</h1>
<p>This Internet-Draft is submitted in full conformance with the provisions of BCP 78 and BCP 79.</p>
<p>Internet-Drafts are working documents of the Internet Engineering Task Force (IETF).  Note that other groups may also distribute working documents as Internet-Drafts.  The list of current Internet-Drafts is at http://datatracker.ietf.org/drafts/current/.</p>
<p>Internet-Drafts are draft documents valid for a maximum of six months and may be updated, replaced, or obsoleted by other documents at any time.  It is inappropriate to use Internet-Drafts as reference material or to cite them other than as "work in progress."</p>
<p>This Internet-Draft will expire on March 26, 2020.</p>
<h1 id="rfc.copyrightnotice">
  <a href="#rfc.copyrightnotice">Copyright Notice</a>
</h1>
<p>Copyright (c) 2019 IETF Trust and the persons identified as the document authors.  All rights reserved.</p>
<p>This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document.  Please review these documents carefully, as they describe your rights and restrictions with respect to this document.  Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.</p>

  
  <hr class="noprint" />
  <h1 class="np" id="rfc.toc"><a href="#rfc.toc">Table of Contents</a></h1>
  <ul class="toc">

  	<li>1.   <a href="#rfc.section.1">Introduction</a></li>
<ul><li>1.1.   <a href="#rfc.section.1.1">Requirements Language</a></li>
</ul><li>2.   <a href="#rfc.section.2">Design Goals</a></li>
<li>3.   <a href="#rfc.section.3">FLIC Structure</a></li>
<ul><li>3.1.   <a href="#rfc.section.3.1">Terminology</a></li>
<li>3.2.   <a href="#rfc.section.3.2">Locators</a></li>
<li>3.3.   <a href="#rfc.section.3.3">Namespaces</a></li>
<li>3.4.   <a href="#rfc.section.3.4">Manifest Metadata</a></li>
<li>3.5.   <a href="#rfc.section.3.5">Pointer Annotations</a></li>
<li>3.6.   <a href="#rfc.section.3.6">Manifest Grammar (ABNF)</a></li>
<li>3.7.   <a href="#rfc.section.3.7">Manifest Trees</a></li>
<ul><li>3.7.1.   <a href="#rfc.section.3.7.1">Traversal</a></li>
</ul><li>3.8.   <a href="#rfc.section.3.8">Manifest Encryption</a></li>
<ul><li>3.8.1.   <a href="#rfc.section.3.8.1">Preshared Key Algorithm</a></li>
<li>3.8.2.   <a href="#rfc.section.3.8.2">RSA Key Encapsulation</a></li>
<li>3.8.3.   <a href="#rfc.section.3.8.3">ECC Group Keys</a></li>
</ul><li>3.9.   <a href="#rfc.section.3.9">Protocol Encodings</a></li>
<ul><li>3.9.1.   <a href="#rfc.section.3.9.1">CCNx Encoding</a></li>
<li>3.9.2.   <a href="#rfc.section.3.9.2">NDN Encoding</a></li>
</ul><li>3.10.   <a href="#rfc.section.3.10">Example Structures</a></li>
<ul><li>3.10.1.   <a href="#rfc.section.3.10.1">Leaf-only data</a></li>
<li>3.10.2.   <a href="#rfc.section.3.10.2">Linear</a></li>
</ul></ul><li>4.   <a href="#rfc.section.4">IANA Considerations</a></li>
<li>5.   <a href="#rfc.section.5">Security Considerations</a></li>
<li>6.   <a href="#rfc.section.6">Appendix A: Building Trees</a></li>
<li>7.   <a href="#rfc.references">References</a></li>
<ul><li>7.1.   <a href="#rfc.references.1">Normative References</a></li>
<li>7.2.   <a href="#rfc.references.2">Informative References</a></li>
</ul><li><a href="#rfc.authors">Authors' Addresses</a></li>


  </ul>

  <h1 id="rfc.section.1"><a href="#rfc.section.1">1.</a> Introduction</h1>
<p id="rfc.section.1.p.1">The purpose of a manifest is to concisely name the constiuent pieces of a larger object.  A FLIC manifest does this by using a first manifest to name and cryptographically sign the data structure and then use more concise lists of hash-based names to indicate the constituent pieces.  This maintains strong security from a single signature.  A Manifest entry gives one enough information to create an Interest for that entry, so it must specify the name, the hash digest, and if needed the locators (routing hints).  </p>
<p id="rfc.section.1.p.2">A key question is how one names the root manifest, the application data, and other subsequent manifests.  The question of namespaces is specific to the names of each Content Object (CCNx) or Data (NDN), and is separate from the question of Locators.  FLIC allows one to use a first namespace for the manifests and a second namespace for the application data.  A given namespace may use one of three schemas: hash-based naming, single-prefix naming, or segmented naming.  We describe the allowed methods in  <a href="#namespaces">Section 3.3</a>.  There are also particulars of how to encode the name schema in a given ICN protocol, which we describe in <a href="#encodings">Section 3.9</a>.  </p>
<p id="rfc.section.1.p.3">Locators are routing hints to find a Content Object / Data.  They exist in both CCNx and NDN, though the specifics differ.  A FLIC manifest encodes locators the same for both ICN protocols, though they are encoded differently in the underlying protocol.  See <a href="#encodings">Section 3.9</a> for encoding differences.  </p>
<p id="rfc.section.1.p.4">We follow the <a href="#RFC8569">CCNx</a> <cite title="NONE">[RFC8569]</cite> terminology where a Content Object is the data structure that holds application payload.  It is made up of an optional Name, a PayloadType, a Payload, and an optional Signature.</p>
<p id="rfc.section.1.p.5">FLIC has encodings for <a href="#CCNxEncoding">CCNx encoding</a> <cite title="NONE">[CCNxEncoding]</cite> as per <a href="#RFC8609">RFC 8609</a> <cite title="NONE">[RFC8609]</cite> and for <a href="#NDNEncoding">NDN</a> <cite title="NONE">[NDNEncoding]</cite>.  </p>
<p id="rfc.section.1.p.6">An example implementation in Python may be found at <a href="#FLICImplementation">[FLICImplementation]</a>.</p>
<h1 id="rfc.section.1.1"><a href="#rfc.section.1.1">1.1.</a> Requirements Language</h1>
<p id="rfc.section.1.1.p.1">The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in <a href="#RFC2119">RFC 2119</a> <cite title="NONE">[RFC2119]</cite>.</p>
<h1 id="rfc.section.2"><a href="#rfc.section.2">2.</a> <a href="#goals" id="goals">Design Goals</a></h1>
<p id="rfc.section.2.p.1">The preferred FLIC structure copies the proven UNIX inode concept of direct and indirect pointers, but without the specific structural forms of direct versus indirect.  </p>
<p id="rfc.section.2.p.2">In FLIC terms, a direct pointer links to application-level data, which is a Content Object with application data in the Payload.  An indirect pointer links to a Content Object with a FLIC Manifest in the Payload.  </p>
<p id="rfc.section.2.p.3">Links in FLIC use hash-based naming of Content Objects, rather than inode block numbers.  Both CCNx and NDN support hash-based naming, though the details vary.  See <a href="#CCNxEncoding">Section 3.9.1</a> and <a href="#NDNEncoding">Section 3.9.2</a>.  Another advantage of using hash-based naming is it permits block-level de-duplication of application data because two blocks with the same payload will have the same hash name.  </p>
<p id="rfc.section.2.p.4">Because FLIC uses hash-based naming, FLIC graphs are inherently acyclic.</p>
<p id="rfc.section.2.p.5">The preferred FLIC structure includes a root manifest with a strong cryptographic signature and then strong hash names to other manifests (e.g. SHA256).  The advantage of this structure is the single signature in the root manifest covers the entire data structure no matter how many additional manifests are in the data structure.  Another advantage of this structure is it removes the need to use chunk (CCNx) or segment (NDN) name components for the subordinate manifests.  </p>
<p id="rfc.section.2.p.6">FLIC supports manifest encryption separate from application payload encryption.  It has a flexible encryption envelope to support various encryption algorithms and key discovery mechanisms.  The byte layout allows for in-place encryption and decryption.</p>
<p id="rfc.section.2.p.7">A limitation of this approach is that one cannot construct a hash-based name for a child until one knows the payload of that child.  In practical terms, this means that one must have the complete application payload available at the time of manifest creation.  </p>
<p id="rfc.section.2.p.8">FLIC's design allows straightforward applications that just need to traverse a linear set of related objects to do so simply, but FLIC has two extensibility mechanisms that allow for more sophisticated uses: manifest metadata, and pointer annotations. These are described in <a href="#metadata">Section 3.4</a> and <a href="#annotations">Section 3.5</a> respectively.  </p>
<h1 id="rfc.section.3"><a href="#rfc.section.3">3.</a> <a href="#structure" id="structure">FLIC Structure</a></h1>
<h1 id="rfc.section.3.1"><a href="#rfc.section.3.1">3.1.</a> <a href="#Terminology" id="Terminology">Terminology</a></h1>
<p/>

<dl>
  <dt>Data Object:</dt>
  <dd style="margin-left: 8">a CCNx nameless Content Object that usually only has Payload. It might also have an ExpiryTime to limit the lifetime of the data.</dd>
  <dt>Direct Pointer:</dt>
  <dd style="margin-left: 8">borrowed from inode terminology, it is a CCNx link using a content object hash restriction and a locator name to point to a Data Object.</dd>
  <dt>Indirect Pointer:</dt>
  <dd style="margin-left: 8">borrowed from inode terminology, it is a CCNx link using a content object hash restriction and a locator name to point to a manifest content object.</dd>
  <dt>Manifest:</dt>
  <dd style="margin-left: 8">a CCNx ContentObject with PayloadType 'Manifest' and a Payload of the encoded manifest. A leaf manifest only has direct pointers. An internal manifest has a mixture of direct and indirect manifests.</dd>
  <dt>Leaf Manifest:</dt>
  <dd style="margin-left: 8">all pointers are direct pointers.</dd>
  <dt>Internal Manifest:</dt>
  <dd style="margin-left: 8">some or all pointers are indirect. The order and number of each is up to the manifest builder. By convention, all the direct manifests come first, then the indirect.</dd>
  <dt>Manifest Waste:</dt>
  <dd style="margin-left: 8">a metric used to measure the amount of waste in a manifest tree. Waste is the number of unused pointers. For example, a leaf manifest might be able to hold 40 direct pointers, but only 30 of them are used, so the waste of this node is 10. Manifest tree waste is the sum of waste over all manifests in a tree.</dd>
  <dt>Root Manifest:</dt>
  <dd style="margin-left: 8">A signed, named, manifest that points to nameless manifest nodes. This structure means that the internal tree structure of internal and leaf manifests have no names and thus may be located anywhere in a namespace, while the root manifest has a name to fetch it by.</dd>
  <dt>Top Manifest:</dt>
  <dd style="margin-left: 8">A preferred manifest structure is to use a Root manifest that points to a single Internal manifest called the Top Manifest. The Top manifest the begins the structure used to organize manifests.</dd>
  <dt>Namespace:</dt>
  <dd style="margin-left: 8">The prefix and object name that goes inside a Content Object. It may include typed name components specifying a version and/or chunk/segment number.</dd>
  <dt>Locator:</dt>
  <dd style="margin-left: 8">A routing hint in an Interest used by forwarding to get the Interest to where it can be matched based on its Namespace-derived name.</dd>
</dl>

<p> </p>
<h1 id="rfc.section.3.2"><a href="#rfc.section.3.2">3.2.</a> <a href="#locators" id="locators">Locators</a></h1>
<p id="rfc.section.3.2.p.1">Locators are routing hints used by forwarders to get an Interest to a node in the network that can resolve the Interest's name.  In some naming conventions, the name might only be a hash-based name so the Locator is the only available routing information.  </p>
<p id="rfc.section.3.2.p.2">A manifest Node may define one or more Locator prefixes that can be used in the construction of Interests from the pointers in the manifest.  The Locators are inherited when walking a manifest tree, so they do not need to be defined everywhere.  It is RECOMMENDED that only the Root manifest contain Locators so that a single operation can update the locators.  One usecase when storing application payloads at different replicas is to replace the Root manifest with a new one that contains locators for the current replicas.  </p>
<h1 id="rfc.section.3.3"><a href="#rfc.section.3.3">3.3.</a> <a href="#namespaces" id="namespaces">Namespaces</a></h1>
<p id="rfc.section.3.3.p.1">A FLIC manifest may define zero or more namespaces.  If none are defined, FLIC uses the default Hash Naming approach.  If using namespaces, typically there are two defined:                    one for the manifest namespace and one for the application data namespace.  If the                    two are the same, they can share a namepace.  There may be more than two namespaces.  </p>
<p id="rfc.section.3.3.p.2">A namespace follows a naming convention.  The naming convention governs how FLIC creates the ICN Name that goes in an Interest's Name and must match a Content Object / Data Name. The conventions are: (1) Hash Naming, (2) Single Prefix, and (3) Segmented Prefix. The default is to use Hash Naming.  Hash Naming does not include anything besides a hash name in the Interest's name and relies on the Locator to forward the Interest. Single Prefix uses the same name differntiated only by a Content Object's implicit hash. Segmented Prefix keeps a counter for the namespace, starting with 0, and increments it after each use of the namespace.  </p>
<p id="rfc.section.3.3.p.3">The namespace definitions may be inherited from the Root manifest or the Top manifest, or any prior manifest.  It is RECOMMENDED that the namespace definitions appear in the Root manifest so they can be updated by a single operation.  Because Segmented Prefix namespaces use a counter, it is RECOMMENDED to only define them in the Root manifest or Top manifest and not elsewhere, as it may confuse the counters.  </p>
<p id="rfc.section.3.3.p.4">In the NodeData, there may be zero or more NSDef contains. Each NSDef defines a namespace identifier (octet string) and its naming convention. For the Hash Naming convention, no further information is required. For the Single Prefix and Segmented Prefix conventions, the NSDef specifies the ICN Name prefix used by the namespace.  </p>
<p id="rfc.section.3.3.p.5">A HashGroup may have an NSRef container that indicates which namespace it is using, and by implication which naming convention and the corresponding prefix. If there is no NSRef, the hash group uses Hash Naming convention.  </p>
<h1 id="rfc.section.3.4"><a href="#rfc.section.3.4">3.4.</a> <a href="#metadata" id="metadata">Manifest Metadata</a></h1>
<p id="rfc.section.3.4.p.1">The FLIC Manifest may be extended by defining TLVs that apply to the Manifest as a whole, or alternatively, individually to every data object pointed to by the Manifest. This basic specification does not specify any, but metadata TLVs may be defined through additional RFCs or via Vendor TLVs.  FLIC uses a Vendor TLV structure similar to <a href="#RFC8609">[RFC8609]</a> for vendor-specific annotations that require no standardiation process.  </p>
<p id="rfc.section.3.4.p.2">For example, some applications may find it useful to allow specialized consumers such as <em>repositories</em> (for example <a href="#repository">[repository]</a>) or enhanced forwarder caches to pre-place, or adaptively pre-fetch data in order to improve robustness of delay performance. We note in passing that FLICs use of separate namespaces for the Manifest and the underlying Data allows different encryption keys to be used, hence giving a element like a cache or repository access to the Manifest data does not as a side effect reveal the contents of the application data itself.  </p>
<h1 id="rfc.section.3.5"><a href="#rfc.section.3.5">3.5.</a> <a href="#annotations" id="annotations">Pointer Annotations</a></h1>
<p id="rfc.section.3.5.p.1">FLIC allows each manifest pointer to be annotated with extra data. Annotations allow applications to exploit metadata about each Data Object pointed to without having to first fetch the corresponding Content Object. This specification defines one such annotation. The <em>SizeAnnotation</em> specifies the number of application layer octets covered by the pointer.  </p>
<p id="rfc.section.3.5.p.2">An annotation may, for example, give hints about a preferred traversal order for fetching the data, or an importance/precedence indication to aid applications that do not require every content object pointed to in the manifest to be fetched. This can be very useful for real-time or streaming media applications that can perform error concealment when rendering the media.  </p>
<p id="rfc.section.3.5.p.3">Additional annotations may be defined through additional RFCs or via Vendor TLVs.  FLIC uses a Vendor TLV structure similar to <a href="#RFC8609">[RFC8609]</a> for vendor-specific annotations that require no standardiation process.  </p>
<h1 id="rfc.section.3.6"><a href="#rfc.section.3.6">3.6.</a> <a href="#grammar" id="grammar">Manifest Grammar (ABNF)</a></h1>
<p id="rfc.section.3.6.p.1">The manifest grammar is mostly independent of the transport ICN protocol. The TLV encoding therefore follows the corresponding ICN protocol, so for CCNx FLIC uses 2 octet length, 2 octet type and for NDN uses the 1/3/5 octet types and lengths.  There are also some differences in how one structures and resolves links. <a href="#RFC8569">[RFC8569]</a> defines HashValue and Link for CCNx encodings. The NDN ImplicitSha256DigestComponent defines HashValue and NDN Delegation (from Link Object) defines Link for NDN. The <a href="#encodings">Section 3.9</a> section below specifies these differences.  </p>
<p id="rfc.section.3.6.p.2">The basic structure of a FLIC manifest is a security context, a node, and an authentication tag.  The security context and authentication tag are not needed if the node is unencrypted.  A node is made up of a set of metadata, the NodeData, that applies to the entire node, and one or more HashGroups that contain pointers.  </p>
<p id="rfc.section.3.6.p.3">The NodeData element defines the namespaces used by the manifest. There may be multiple namespaces, depending on how one names subsequent  manifests or data objects.  Each HashGroup may reference a single namespace to control how one forms Interests from the HashGroup.  If one is using separate namespaces for manifests and application data, one needs at least two HashGroups.  For a manifest structure of "MMMDDD," for example, one would have a first hash group for the child manifests with its namespace and a second HashGroup for the data pointers with the other namespace. If one used a structure like "MMMDDDMMM," then one would need three HashGroups.  </p>
<div id="rfc.figure.1"/>
<div id="flicgrammar"/>
<pre>
TYPE = 2OCTET / {1,3,5}OCTET ; As per CCNx or NDN TLV
LENGTH = 2OCTET / {1,3,5}OCTET ; As per CCNx or NDN TLV

Manifest = TYPE LENGTH [SecurityCtx] (EncryptedNode / Node) [AuthTag]

SecurityCtx = TYPE LENGTH AlgorithmCtx
AlgorithmCtx = PresharedKeyCtx / others
AuthTag = TYPE LENGTH *OCTET ; e.g. AEAD authentication tag
EncryptedNode = TYPE LENGTH *OCTET ; Encrypted Node

Node = TYPE LENGTH [NodeData] 1*HashGroup
NodeData = TYPE LENGTH [SubtreeSize] [SubtreeDigest] [Locators] 0*NSDef
SubtreeSize = TYPE LENGTH INTEGER
SubtreeDigest = TYPE LENGTH HashValue
NSDef = TYPE LENGTH NsId NsSchema
NsId = TYPE LENGTH INTEGER
NsSchema = HashSchema / SinglePrefixSchema / SegmentedPrefixSchema
HashSchema = TYPE 0
SinglePrefixSchema = TYPE LENGTH Name
SegmentedPrefixSchema = TYPE LENGTH Name

Locators = TYPE LENGTH 1*Link
HashValue = TYPE LENGTH *OCTET ; As per ICN Protocol
Link = TYPE LENGTH *OCTET ; As per ICN protocol

HashGroup = TYPE LENGTH [GroupData] (Ptrs / AnnotatedPtrs)
Ptrs = TYPE LENGTH *HashValue
AnnotatedPtrs = TYPE LENGTH *PointerBlock
PointerBlock = TYPE LENGTH *Annotation Ptr
Ptr = TYPE LENGTH HashValue

Annotation = SizeAnnotation / Vendor
SizeAnnotation = TYPE LENGTH Integer
Vendor = TYPE LENGTH PEN *OCTET

GroupData = TYPE LENGTH [LeafSize] [LeafDigest] [SubtreeSize] [SubtreeDigest] [NsId]
LeafSize = TYPE LENGTH INTEGER
LeafDigest = TYPE LENGTH HashValue

PresharedKeyCtx = TYPE LENGTH PresharedKeyData
PresharedKeyData = KeyNum IV Mode
KeyNum = TYPE LENGTH INTEGER
IV = TYPE LENGTH 1*OCTET
Mode = TYPE LENGTH (AES-GCM-128 / AES-GCM-256)

RsaKemCtx = 2 LENGTH RsaKemData
RsaKemData = KeyId IV Mode WrappedKey LocatorPrefix
KeyId = TYPE LENGTH HashValue; ID of Key Encryption Key
WrappedKey = TYPE LENGTH 1*OCTET
LocatorPrefix = TYPE LENGTH Link
                    </pre>
<p class="figure">Figure 1: FLIC Grammar</p>
<p/>

<dl>
  <dt>SecurityCtx:</dt>
  <dd style="margin-left: 8">information about how to decrypt an EncryptedNode. The structure will depend on the specific encryption algorithm.</dd>
  <dt>AlgorithmId:</dt>
  <dd style="margin-left: 8">The ID of the encryption method (e.g. preshared key, a broadcast encryption scheme, etc.)</dd>
  <dt>AlgorithmData:</dt>
  <dd style="margin-left: 8">The context for the encryption algorithm.</dd>
  <dt>EncryptedNode:</dt>
  <dd style="margin-left: 8">An opaque octet string with an optional authentication tag (i.e. for AEAD authentication tag)</dd>
  <dt>Node:</dt>
  <dd style="margin-left: 8">A plain-text manifest node. The structure allows for in-place encryption/decryption.</dd>
  <dt>NodeData:</dt>
  <dd style="margin-left: 8">the metadata about the Manifest node</dd>
  <dt>SubtreeSize:</dt>
  <dd style="margin-left: 8">The size of all application data at and below the Node or Group</dd>
  <dt>SubtreeDigest:</dt>
  <dd style="margin-left: 8">The cryptographic digest of all application data at and below the Node or Group</dd>
  <dt>Locators:</dt>
  <dd style="margin-left: 8">An array of routing hints to find the manifest components</dd>
  <dt>HashGroup:</dt>
  <dd style="margin-left: 8">A set of child pointers and associated metadata</dd>
  <dt>Ptrs:</dt>
  <dd style="margin-left: 8">A list of one or more Hash Values</dd>
  <dt>GroupData:</dt>
  <dd style="margin-left: 8">Metadata that applies to a HashGroup</dd>
  <dt>LeafSize:</dt>
  <dd style="margin-left: 8">Size of all application data immediately under the Group (i.e. via direct pointers)</dd>
  <dt>LeafDigest:</dt>
  <dd style="margin-left: 8">Digest of all application data immediately under the Group</dd>
  <dt>Ptr:</dt>
  <dd style="margin-left: 8">The ContentObjectHash of a child, which may be a data ContentObject (i.e. with Payload) or another Manifest Node.</dd>
  <dt></dt>
  <dd style="margin-left: 8"/>
  <dt></dt>
  <dd style="margin-left: 8"/>
</dl>

<p> </p>
<h1 id="rfc.section.3.7"><a href="#rfc.section.3.7">3.7.</a> <a href="#trees" id="trees">Manifest Trees</a></h1>
<h1 id="rfc.section.3.7.1"><a href="#rfc.section.3.7.1">3.7.1.</a> <a href="#traversal" id="traversal">Traversal</a></h1>
<p id="rfc.section.3.7.1.p.1">FLIC manifests use a pre-order traversal.  This means they are read top to bottom, left to right.  The algorithms in <a href="#pseudocode">Figure 2</a> show the in-order forward traversal code and the reverse-oder traversal code, which we use below to construct such a tree.  This document does not mandate how to build trees.  Appendix A provides a detailed example of building inode-like trees.  </p>
<p id="rfc.section.3.7.1.p.2">If using Annotated Pointers, an annotation could influence the traversal order.  </p>
<div id="rfc.figure.2"/>
<div id="pseudocode"/>
<pre>
preorder(node)
    if (node = null)
        return
    visit(node)
    for (i = 0, i &lt; node.child.length, i++)
        preorder(node.child[i])
                                
reverse_preorder(node)
    if (node = null)
        return
    for (i = node.child.length - 1, i &gt;= 0, i-- )
    reverse_preorder(node.child[i])
        visit(node)
                            </pre>
<p class="figure">Figure 2: Traversal Pseudocode</p>
<p/>
<p id="rfc.section.3.7.1.p.4">In terms of the FLIC grammar, one expands a node into its hash groups, visiting each hash group in order.  In each hash group, one follows each pointer in order.  Figure <a href="#expansion">Figure 3</a> shows how hash groups inside a manifest expand like virtual children in the tree.  The in-order traversal is M0, HG1, M1, HG3, D0, D1, D2, HG2, D3, D4.  </p>
<div id="rfc.figure.3"/>
<div id="expansion"/>
<pre>
M0 ____
|      \
HG1    HG2
| \    |  \
M1 D2  D3  D4
|
HG3
|  \
D0 D1
                        </pre>
<p class="figure">Figure 3: Node Expansion</p>
<p id="rfc.section.3.7.1.p.5">Using the example manifest tree shown in Figure <a href="#leafonly">Figure 9</a>, the in-order traversal would be: Root, M0, M1, D0, D1, D2, M2, D3, D4, D5, M3, D6, D7, D8.  </p>
<h1 id="rfc.section.3.8"><a href="#rfc.section.3.8">3.8.</a> <a href="#encryption" id="encryption">Manifest Encryption</a></h1>
<p id="rfc.section.3.8.p.1">This document specifies three encryption methods.  The first is a preshared key algorithm, where the parties are assumed to have the decryption keys already.  This is useful, for example, when using a key agreement protocol such as CCNxKE.  The second is an RSA key encapsulation mechanisms.  The third is a group encryption mechanism, where the Top manifest specifies how a group member may fetch the decryption keys.  </p>
<h1 id="rfc.section.3.8.1"><a href="#rfc.section.3.8.1">3.8.1.</a> <a href="#preshared" id="preshared">Preshared Key Algorithm</a></h1>
<p id="rfc.section.3.8.1.p.1">The KeyNum identifies a key on the receiver. The key must be of the correct length of the Mode used.  If the key is longer, use the left bits. Many receivers many have the same key with the same KeyId.  A publisher creates a signed root manifest with a security context. A consumer must ensure that the root manifest signer is the expected publisher for use with the pre-shared key, which may be shared with many other consumers. The publisher may use either method 8.2.1 (deterministic IV) or 8.2.2 (RBG-based IV) [NIST 800-38D] for creating the IV.  </p>
<p id="rfc.section.3.8.1.p.2">Each encrypted manifest node (root manifest or internal manifest) has a full security context (KeyNum, IV, Mode). The AES-GCM decryption is independent for each manifest so Manifest objects can be fetched and decrypted in any order. This design also ensures that if a manifest tree points to the same subtree repeatedly, such as for deduplication, the decryptions are all idempotent.  </p>
<p id="rfc.section.3.8.1.p.3">The functions for authenticated encryption and authenticated decryption are as given in Sections 7.1 and 7.2 of NIST 800-38D: GCM-AE_K(IV, P, A) and GCM-AD_K(IV, C, A, T).  </p>
<div id="rfc.figure.4"/>
<div id="pskencrypt"/>
<pre>
EncryptNode(SecurityCtx, Node, K, IV) -&gt; GCM-AE_K(IV, P, A) -&gt; (C, T)
    Node: The wire format of the Node (P)
    SecurityCtx: The wire format of the SecurityCtx as the Additional Authenticated Data (A)
    K: the pre-shared key (128 or 256 bits)
    IV: The initialization vector (usually 96 or 128 bits)
    C: The cipher text
    T: The authentication tag
                        </pre>
<p class="figure">Figure 4: Preshared Key Encrypt</p>
<p id="rfc.section.3.8.1.p.4">The pair (C,T) is the OpaqueNode encoded as a TLV structure: (OpaqueNode (CipherText C) (AuthTag T)).</p>
<div id="rfc.figure.5"/>
<div id="pskdecrypt"/>
<pre>
DecryptNode(SecurityCtx, C, T, K, IV) -&gt; GCM-AD_K (IV, C, A, T) -&gt; (Node, FailFlag)
Node: The wire format of the decrypted Node
FailFlag: Indicates authenticated decryption failure (true or false)
                        </pre>
<p class="figure">Figure 5: Preshared Key Decrypt</p>
<p id="rfc.section.3.8.1.p.5">If doing in-place decryption, the cipher text C will be enclosed in an EncryptedNode TLV value.  After decryption, change the TLV type to Node. The length should be the same. After decryption the AuthTag is no longer needed. The TLV type should be changed to T_PAD and the value zeroed.  The SecurityCtx could be changed to T_PAD and zeroed or left as-is.  </p>
<h1 id="rfc.section.3.8.2"><a href="#rfc.section.3.8.2">3.8.2.</a> <a href="#rsakem" id="rsakem">RSA Key Encapsulation</a></h1>
<p id="rfc.section.3.8.2.p.1">See also RFC 5990, NIST SP 800-56B Rev. 2 and https://lists.w3.org/Archives/Public/public-xmlsec/2009May/att-0032/Key_Encapsulation.pdf </p>
<p id="rfc.section.3.8.2.p.2">In this system, a key manager (KM) (which could be the publisher) creates a Content Encryption Key (CEK) and a key wrapping pair with a Key Encryption Key (KEK) and Key Decryption Key (KDK).  Each publisher and consumer has its own public/private key pair, and the KM knows each publisher's and consumer's identity and its public key (PK_x).  </p>
<p id="rfc.section.3.8.2.p.3">We do not describe the publisher-key manager protocol to request a CEK. The publisher will obtain the (CEK, E_KEK(Z), KeyId, Locator), where each element is: the content encryption key, the CEK precursor, Z, encrypted with the KEK (an RSA operation), and the KeyId of the corresponding KDK, and the Locator is the CCNx name prefix to fetch the KDK (see below). The precursor Z is chosen randomly z &lt; n-1, where n is KEK's public modulus. Note that CEK = KDF(Z). Note that the publisher does not see KEK or Z.  </p>
<p id="rfc.section.3.8.2.p.4">We use HKDF (RFC 5869) for the KDF. CEK = HKDF-Expand(HKDF-Extract(0, Z), "CEK", KeyLen), where KenLen is usually 32 bytes (256 bits).  </p>
<p id="rfc.section.3.8.2.p.5">In the ABNF grammar, the RsaKemData includes a KeyId, IV, Mode, WrappedKey, and LocatorPrefix.  The KeyId is the ID (sha256) of the KEK.  The IV and Mode are as per preshared key, and describe how the manifest is encrypted with AES-GCM.  The WrappedKey is the AES key to decrypt the manifest.  The LocatorPrefix is used to construct an Interest to fetch the KDK.  </p>
<p id="rfc.section.3.8.2.p.6">To fetch the KDK, a consumer with public key PK_c constructs an Interest with name /LocatorPrefix/{KeyId}/{PK_c keyid} and a KeyIdRestriction of the KM's KeyId (from the LocatorPrefix Link).  It should receive back a signed Content Object with the KDK wrapped for the consumer, or a NAK from the KM.  The payload of the ContentObject will be RsaKemWrap(PK, KDK). The signed ContentObject must have a KeyLocator to the KM's public key. The consumer will trust the KM's public key because the publisher, whom the consumer trusts, relayed that KeyId inside its own signed Manifest.  </p>
<p id="rfc.section.3.8.2.p.7">The signed Content Object should have an ExpiryTime, which may be shorter than the Manifest's, but should not be substantially longer than the Manifest's ExpiryTime. The KM may decide how to handle the Recommended Cache Time, or if caching of the response is even permissible. The KM may require on-line fetching of the response via a CCNxKE encrypted transport tunnel.  </p>
<div id="rfc.figure.6"/>
<div id="rsakemwrap"/>
<pre>
RsaKemWrap(PK, K, KeyLen = 256):
    choose z &lt; n-1, where n is PK's public modulus
    encrypt c = z^e mod n
    prk = HKDF-Extract(0, Z)
    kek = HKDF-Expand(prk, "RsaKemWrap", KeyLen)
    WK = E_KEK(K) # [AES-WRAP, RFC 3394]
    output (c, WK)
                        </pre>
<p class="figure">Figure 6: RSA KEM Wrap</p>
<p id="rfc.section.3.8.2.p.8">A consumer must verify the signed content object's signature against the Key Manager's public key.  The consumer then unwraps the KDK from the Content Object's payload using RsaKemUnwrap().  The KeyLen is taken from the WrapMode parameter.  </p>
<div id="rfc.figure.7"/>
<div id="rsakemunwrap"/>
<pre>
RsaKemUnwrap(SK, c, WK, KeyLen = 256):
    Using the consumers private key SK, decrypt Z from c.
    prk = HKDF-Extract(0, Z)
    kek = HKDF-Expand(prk, "RsaKemWrap", KeyLen)
    K = D_KEK(WK) # [AES-UNWRAP, RFC 33940]
    output K
                        </pre>
<p class="figure">Figure 7: RSA KEM Unwrap</p>
<p id="rfc.section.3.8.2.p.9">The consumer then unwraps the CEK precursor by using the KDK to decrypt Z. It then derives CEK as above.  Manifest encryption and decryption proceed as with PresharedKey, but using the CEK.  </p>
<h1 id="rfc.section.3.8.3"><a href="#rfc.section.3.8.3">3.8.3.</a> <a href="#group" id="group">ECC Group Keys</a></h1>
<p id="rfc.section.3.8.3.p.1">NOTE: THIS IS INFORMALLY SPECIFIED AT THIS STAGE</p>
<p id="rfc.section.3.8.3.p.2">We use an EC group key that is encrypted for each user under their public key (also assumed EC) using a standard NIST wrapping C(1e, 2s, ECC CDH)-ECDSA plus AES-KWP.  When a publisher wants to publish, it creates an EC wrapping keypair and publishes the private key wrapped under the group key (use C(1e, 1s, ECC CDH)-ECDSA plus AES-KWP).  Finally, the publisher starts creating master secrets by creating ECDHE-ECDSA offers under the wapping key and using a KDF (e.g. HMAC-SHA256) for the data key.  </p>
<p id="rfc.section.3.8.3.p.3">Note that the offer, in this case, is just an ephemeral EC public key plus the curve specification.  In compressed form that EC public key is only 48 bytes (SECP384R1), so the whole offer is maybe 60 bytes including TLV encoding.  Compare that to an RSA 4096-bit encryption of a 32-byte AES key at 512 bytes.  That's over an 8x improvement.  </p>
<p id="rfc.section.3.8.3.p.4">The complete security context would be larger, as you still need the keyid of the wrapping key (32 bytes) plus a link to the wrapping key content object.  Once someone has the wrapping key, they can verify the key id and avoid fetching anything, then calculate the shared secret from the ECDHE offer, then derive the data key using a KDF.   For IoT use cases, it would be useful to be able to link to the whole offer.  </p>
<p id="rfc.section.3.8.3.p.5">The KDF is tied to input from the manifest, so the publisher can create many data keys so each FLIC manifest tree has a different key all from the same master key derived from the wrapping key.  The offers could be embedded in the root manifest or published externally.  The preferred method is to embed the offer in the root manifest.  When the group key changes, a publisher only needs to re-encrypt the wrapping keys.  It can save a lot of work depending on how many items it used the wrapping key under that group key.  For example, if the publisher uses only one wrapping key per group key, then they only need to re-encrypt one thing for the new group to have access to the old data.  </p>
<p id="rfc.section.3.8.3.p.6">This works with RSA keys too, though the specific algorithms change some.  We would use RSA-OAEP instead of the ECDHE method.  </p>
<p id="rfc.section.3.8.3.p.7">TODO: There are a variety of issues about how you name the keys and publish them.  We would also need to decide if we want key fetching to be on-line or available from repos, and if so how to do current key fetching.  </p>
<h1 id="rfc.section.3.9"><a href="#rfc.section.3.9">3.9.</a> <a href="#encodings" id="encodings">Protocol Encodings</a></h1>
<h1 id="rfc.section.3.9.1"><a href="#rfc.section.3.9.1">3.9.1.</a> <a href="#CCNxEncoding" id="CCNxEncoding">CCNx Encoding</a></h1>
<p id="rfc.section.3.9.1.p.1">Hash Naming convention in CCNx uses nameless objects.  TODO: Spell out encoding.  </p>
<div id="rfc.figure.8"/>
<div id="CCNxGrammer"/>
<pre>
ManifestContentObject = TYPE LENGTH [Name] [ExpiryTime] PayloadType Payload
Name = TYPE LENGTH *OCTET ; As per RFC8569
ExpiryTime = TYPE LENGTH *OCTET ; As per RFC8569
PayloadType = TYPE LENGTH T_PYLDTYPE_MANIFEST ; Value TBD
Payload : TYPE LENGTH *OCTET ; the serialized Manifest object
                        </pre>
<p class="figure">Figure 8: CCNx Embedding Grammar</p>
<h1 id="rfc.section.3.9.2"><a href="#rfc.section.3.9.2">3.9.2.</a> <a href="#NDNEncoding" id="NDNEncoding">NDN Encoding</a></h1>
<p id="rfc.section.3.9.2.p.1">In Hash Naming, the Interest name is only the Implicit Digest name component and the ForwardingHints come from the Locators.  This means that the Manifest namespace and data namespace are the same and could use the same NSDef.  It also means that the Data name is empty (0-length).  </p>
<p id="rfc.section.3.9.2.p.2">In Single Prefix, the Data name is a common prefix used between all objects in that namespace, without a Segment or other counter.  They are distinguished via the Implicit Digest name component.  The FLIC Locators go in the ForwardingHints.  </p>
<p id="rfc.section.3.9.2.p.3">In Segmented Prefix, the Data name is a common prefix plus a segment number, so each manifest or application data object has a unique full name before the implicit digest.  This means the consumer must maintain a counter for each namespace.  It will also remove the possibility of doing some name-based data de-duplication.  OPTIONAL: Use AnnotatedPointers to indicate the segment number of each hash pointer to avoid needing to infer the segment numbers.  </p>
<h1 id="rfc.section.3.10"><a href="#rfc.section.3.10">3.10.</a> Example Structures</h1>
<h1 id="rfc.section.3.10.1"><a href="#rfc.section.3.10.1">3.10.1.</a> Leaf-only data</h1>
<div id="rfc.figure.9"/>
<div id="leafonly"/>
<pre>
           Root
            |
     ______ M0 _____
    /       |       \
   M1       M2       M3
 / | \    / | \    / | \
D0 D1 D2 D3 D4 D5 D6 D7 D8
                        </pre>
<p class="figure">Figure 9: Leaf-only manifest tree</p>
<h1 id="rfc.section.3.10.2"><a href="#rfc.section.3.10.2">3.10.2.</a> Linear</h1>
<p id="rfc.section.3.10.2.p.1">Of special interest are "skewed trees" where a pointer to a manifest may only appear as last pointer of (sub-) manifests. Such a tree becomes a sequential list of manifests with a maximum of datapointers per manifest packet. Beside the tree shape we also show this data structure in form of packet content where D stands for a data pointer and M is the hash of a manifest packet.</p>
<pre>
Root -&gt; M0 ----&gt; M1 ----&gt; ...
|-&gt;DDDD  |-&gt;DDDD
                        </pre>
<h1 id="rfc.section.4"><a href="#rfc.section.4">4.</a> <a href="#IANA" id="IANA">IANA Considerations</a></h1>
<p id="rfc.section.4.p.1">TODO Need IANA actions: <a href="#RFC8609">[RFC8609]</a> </p>

<ul>
  <li>Create a registry for Manifest Data and Annotation TLVs</li>
  <li>Register the SizeAnnotation TLV</li>
</ul>

<p> Also TODO: If this document is submitted as an official RG draft, this section must be updated to reflect the IANA registries described in </p>
<h1 id="rfc.section.5"><a href="#rfc.section.5">5.</a> <a href="#Security" id="Security">Security Considerations</a></h1>
<h1 id="rfc.section.6"><a href="#rfc.section.6">6.</a> <a href="#AppendixA" id="AppendixA">Appendix A: Building Trees</a></h1>
<p id="rfc.section.6.p.1">This section describes one method to build trees.  It constructs a pre-order tree in a single pass of the application data, going from the tail to the beginning.  This allows us to work up the right side of the tree in a single pass, then work down each left branch until we exhaust the data.  Using the reverse-order traversal, we create the right-most-child manifest, then its parent, then the indirect pointers of that parent, then the parent's direct pointers, then the parent of the parent (repeating). This process uses recursion, as it is the clearest way to show the code. A more optimized approach could do it in a true single pass.  </p>
<p id="rfc.section.6.p.2">Because we're building from the bottom up, we use the term 'level' to be the distance from the right-most child up. Level 0 is the bottom-most level of the tree, such as where node 7 is: </p>
<pre>
      1
  2      3
4  5    6  7
preorder: 1 2 4 5 3 6 7
reverse:  7 6 3 5 4 2 1
                </pre>
<p id="rfc.section.6.p.3">The Python-like pseudocode build_tree(data, n, k, m) algorithm creates a tree of n data objects.  The data[] array is an array of Content Objects that hold application payload; the application data has already been packetized into n Content Object packets.  An interior manifest node has k direct pointers and m indirect pointers.  </p>
<pre>
build_tree(data[0..n-1], n, k, m)
    # data is an array of Content Objects (Data in NDN) with application payload.
    # n is the number of data items
    # k is the number of direct pointers per internal node
    # m is the number of indirect pointers per internal node
            
    segment = namedtuple('Segment', 'head tail')(0, n)
    level = 0
    
    # This bootstraps the process by creating the right most child manifest
    # A leaf manifest has no indirect pointers, so k+m are direct pointers
    root = leaf_manifest(data, segment, k + m)
    
    # Keep building subtrees until we're out of direct pointers
    while not segment.empty():
        level += 1
        root = bottom_up_preorder(data, segment, level, k, m, root)
    
    return root
                </pre>
<pre>
bottom_up_preorder(data, segment, level, k, m, right_most_child=None)
    manifest = None
    if level == 0:
        assert right_most_child is None
        # build a leaf manifest with only direct pointers
        manifest = leaf_manifest(data, segment, k + m)
    else:
        # If the number of remaining direct pointers will fit in a leaf node, make one of those.
        # Otherwise, we need to be an interior node
        if right_most_child is None and segment.length() &lt;= k + m:
            manifest = leaf_manifest(data, segment, k+m)
        else:
            manifest = interior_manifest(data, segment, level, k, m, right_most_child)
    return manifest
                </pre>
<pre>
leaf_manifest(data, segment, count)
    # At most count items, but never go before the head
    start = max(segment.head(), segment.tail() - count)
    manifest = Manifest(data[start:segment.tail])
    segment.tail -= segment.tail() - start
    return manifest
                </pre>
<pre>
interior_manifest(data, segment, level, k, m, right_most_child)
    children = []
    if right_most_child is not None:
        children.append(right_most_child)
    
    interior_indirect(data, segment, level, k, m, children)
    interior_direct(data, segment, level, k, m, children)
    
    manifest = Manifest(children)
    return manifest, tail
                </pre>
<pre>
interior_indirect(data, segment, level, k, m, children)
    # Reserve space at the head of the segment for this node's direct pointers before
    # descending to children.  We want the top of the tree packed.
    reserve_count = min(m, segment.tail - segment.head)
    segment.head += reserve_count
    
    while len(children) &lt; m and not segment.head == segment.tail:
        child = bottom_up_preorder(data, segment, level - 1, k, m)
        # prepend
        children.insert(0, child)
    
    # Pull back our reservation and put those pointers in our direct children
    segment.head -= reserve_count
                </pre>
<pre>
interior_direct(data, segment, level, k, m, children)
    while len(children) &lt; k+m and not segment.head == segment.tail:
        pointer = data[segment.tail() - 1]
        children.insert(0, pointer)
        segment.tail -= 1
                </pre>
<h1 id="rfc.references"><a href="#rfc.references">7.</a> References</h1>
<h1 id="rfc.references.1"><a href="#rfc.references.1">7.1.</a> Normative References</h1>
<table>
  <tbody>
    <tr>
      <td class="reference">
        <b id="RFC2119">[RFC2119]</b>
      </td>
      <td class="top"><a>Bradner, S.</a>, "<a href="http://tools.ietf.org/html/rfc2119">Key words for use in RFCs to Indicate Requirement Levels</a>", BCP 14, RFC 2119, DOI 10.17487/RFC2119, March 1997.</td>
    </tr>
  </tbody>
</table>
<h1 id="rfc.references.2"><a href="#rfc.references.2">7.2.</a> Informative References</h1>
<table>
  <tbody>
    <tr>
      <td class="reference">
        <b id="FLICImplementation">[FLICImplementation]</b>
      </td>
      <td class="top"><a>Mosko, M.</a>, "<a href="https://github.com/mmosko/ccnpy">FLIC Implementation in Python</a>", various.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="NDN">[NDN]</b>
      </td>
      <td class="top"><a>NDN team, </a>, "<a href="https://named-data.net/project/execsummary/">Named Data Networking</a>", various.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="NDNTLV">[NDNTLV]</b>
      </td>
      <td class="top"><a>NDN Project Team, </a>, "<a href="http://named-data.net/doc/ndn-tlv/">NDN Packet Format Specification.</a>", 2016.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="repository">[repository]</b>
      </td>
      <td class="top"><a>NDN Project Team, </a>, "<a href="https://redmine.named-data.net/projects/repo-ng/wiki/Repo_Protocol_Specification">Repo Protocol Specification</a>", Various.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC3552">[RFC3552]</b>
      </td>
      <td class="top"><a>Rescorla, E.</a> and <a>B. Korver</a>, "<a href="http://tools.ietf.org/html/rfc3552">Guidelines for Writing RFC Text on Security Considerations</a>", BCP 72, RFC 3552, DOI 10.17487/RFC3552, July 2003.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC5226">[RFC5226]</b>
      </td>
      <td class="top"><a>Narten, T.</a> and <a>H. Alvestrand</a>, "<a href="http://tools.ietf.org/html/rfc5226">Guidelines for Writing an IANA Considerations Section in RFCs</a>", RFC 5226, DOI 10.17487/RFC5226, May 2008.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC8569">[RFC8569]</b>
      </td>
      <td class="top"><a>Mosko, M.</a>, <a>Solis, I.</a> and <a>C. Wood</a>, "<a href="http://tools.ietf.org/html/rfc8569">Content-Centric Networking (CCNx) Semantics</a>", RFC 8569, DOI 10.17487/RFC8569, July 2019.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC8609">[RFC8609]</b>
      </td>
      <td class="top"><a>Mosko, M.</a>, <a>Solis, I.</a> and <a>C. Wood</a>, "<a href="http://tools.ietf.org/html/rfc8609">Content-Centric Networking (CCNx) Messages in TLV Format</a>", RFC 8609, DOI 10.17487/RFC8609, July 2019.</td>
    </tr>
  </tbody>
</table>
<h1 id="rfc.authors">
  <a href="#rfc.authors">Authors' Addresses</a>
</h1>
<div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Christian Tschudin</span> 
	  <span class="n hidden">
		<span class="family-name">Tschudin</span>
	  </span>
	</span>
	<span class="org vcardline">University of Basel</span>
	<span class="adr">
	  
	  <span class="vcardline">
		<span class="locality"></span> 
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline"></span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:christian.tschudin@unibas.ch">christian.tschudin@unibas.ch</a></span>

  </address>
</div><div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Christopher A. Wood</span> 
	  <span class="n hidden">
		<span class="family-name">Wood</span>
	  </span>
	</span>
	<span class="org vcardline">University of California Irvine</span>
	<span class="adr">
	  
	  <span class="vcardline">
		<span class="locality"></span> 
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline"></span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:woodc1@uci.edu">woodc1@uci.edu</a></span>

  </address>
</div><div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Marc Mosko</span> 
	  <span class="n hidden">
		<span class="family-name">Mosko</span>
	  </span>
	</span>
	<span class="org vcardline">PARC, Inc.</span>
	<span class="adr">
	  
	  <span class="vcardline">
		<span class="locality"></span> 
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline"></span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:marc.mosko@parc.com">marc.mosko@parc.com</a></span>

  </address>
</div>

</body>
</html>

