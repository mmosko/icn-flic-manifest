<!DOCTYPE html>
<html lang="en" class="Internet-Draft">
<head>
<meta charset="utf-8">
<meta content="Common,Latin" name="scripts">
<meta content="initial-scale=1.0" name="viewport">
<title>File-Like ICN Collections (FLIC)</title>
<meta content="Christian Tschudin" name="author">
<meta content="Christopher A. Wood" name="author">
<meta content="Marc Mosko" name="author">
<meta content="David Oran" name="author">
<meta content="
       This document describes a bare bones &quot;index table&quot;-approach for
                organizing a set of ICN data objects into a large, File-Like
                ICN Collection (FLIC).
                
                At the core of this collection is a so called manifest which acts as
                the collection's root node. The manifest contains an index table with
                pointers, each pointer being a hash value pointing to either a final
                data block or another index table node. 
    " name="description">
<meta content="xml2rfc 3.7.0" name="generator">
<meta content="Information Centric Networking" name="keyword">
<meta content="draft-tschudin-icnrg-flic-latest" name="ietf.draft">
<!-- Generator version information:
  xml2rfc 3.7.0
    Python 3.7.6
    appdirs 1.4.4
    ConfigArgParse 1.4
    google-i18n-address 2.4.0
    html5lib 1.1
    intervaltree 3.1.0
    Jinja2 2.11.3
    kitchen 1.2.6
    lxml 4.6.2
    pycountry 20.7.3
    pyflakes 2.3.0
    PyYAML 5.4.1
    requests 2.25.1
    setuptools 42.0.2
    six 1.15.0
-->
<link href="draft-tschudin-icnrg-flic.xml" rel="alternate" type="application/rfc+xml">
<link href="#copyright" rel="license">

<style type="text/css">/*<![CDATA[*/

body {
  font: 16px "Helvetica Neue","Open Sans",Helvetica,Calibri,sans-serif;
  color: #333;
  font-size-adjust: 0.5;
  line-height: 24px;
  margin: 75px auto;
  max-width: 624px;
  padding: 0 5px;
}

.title, .filename, h1, h2, h3, h4, h5 {
  font: 16px "Roboto Condensed","Helvetica Neue","Open Sans",Helvetica,Calibri,sans-serif;
  font-size-adjust: 0.5;
  font-weight: bold;
  color: #333;
  line-height: 100%;
  margin: 1.2em 0 0.3em;
}
.title, #rfc\.title h1 { font-size: 32px; }
h1, section h1, h2, section h2, section h3, nav h2 { font-size: 20px; }
h3, section h4, h4, section h5 { font-size: 16px; }
h1 a[href], h2 a[href], h3 a[href], h4 a[href] {
  color: #333;
}

table {
  margin-left: 0em;
  border-collapse: collapse;
}
th {
  text-align: left;
  border-bottom: 2px solid #ddd;
}
td {
  border-top: 1px solid #ddd;
  vertical-align: top;
}
tr:nth-child(2n+1) > td,
tr:nth-child(2n+1) > th {
  background-color: #f9f9f9;
}
td.reference {
  max-width: 200px;
  border-top: none;
  padding-right: 1em;
}
.right {
  text-align: right;
}


table.header, table#rfc\.headerblock {
  width: 100%;
}
table.header td, table#rfc\.headerblock td {
  border: none;
  background-color: transparent;
  color: black;
  padding: 0;
}
.filename {
  display: block;
  color: rgb(119, 119, 119);
  font-size: 20px;
  font-weight: normal;
  line-height: 100%;
  margin: 10px 0 32px;
}
#rfc\.abstract+p, #rfc\.abstract+p code, #rfc\.abstract+p samp, #rfc\.abstract+p tt {
  font-size: 20px;
  line-height: 28px;
}

samp, tt, code, pre, span.tt {
  font-size: 13.5px;
  font-family: Consolas, monospace;
  font-size-adjust: none;
}
pre {
  background-color: #eee;
  border: 1px solid #ddd;
  overflow-x: auto;
  padding: 5px;
  margin: 5px;
}
.figure, caption {
  font-style: italic;
  margin: 0 1.5em;
  text-align: left;
}

address {
  margin: 16px 2px;
  line-height: 20px;
}
.vcard {
  font-style: normal;
}
.vcardline {
  display: block;
}
.vcardline .fn, address b {
  font-weight: normal;
}
.vcardline .hidden {
  display: none;
}

dl {
  margin-left: 1em;
}
dl.dl-horizontal: {
  margin-left: 0;
}
dl > dt {
  float: left;
  margin-right: 1em;
}
dl.nohang > dt {
  float: none;
}
dl > dd {
  margin-bottom: .5em;
}
dl.compact > dd {
  margin-bottom: 0em;
}
dl > dd > dl {
  margin-top: 0.5em;
  margin-bottom: 0em;
}
ul.empty {
  list-style-type: none;
}
ul.empty li {
  margin-top: .5em;
}

hr {
  border: 0;
  border-top: 1px solid #eee;
}
hr.noprint {
  display: none;
}

a {
  text-decoration: none;
}
a[href] {
  color: #2a6496;
}
a[href]:hover {
  background-color: #eee;
}

p, ol, ul, li {
  padding: 0;
}
p {
  margin: 0.5em 0;
}
ol, ul {
  margin: 0.2em 0 0.2em 2em;
}
li {
  margin: 0.2em 0;
}
address {
  font-style: normal;
}

ul.toc ul {
  margin: 0 0 0 2em;
}
ul.toc li {
  list-style: none;
  margin: 0;
}

@media screen and (min-width: 924px) {
  body {
    padding-right: 350px;
  }
  body>ul.toc, body>#rfc\.toc {
    position: fixed;
    bottom: 0;
    right: 0;
    right: calc(50vw - 500px);
    width: 300px;
    z-index: 1;
    overflow: auto;
    overscroll-behavior: contain;
  }
  body>#rfc\.toc {
    top: 55px;
  }
  body>ul.toc {
    top: 100px;
  }

  ul.toc {
    margin: 0 0 0 4px;
    font-size: 12px;
    line-height: 20px;
  }
  ul.toc ul {
    margin-left: 1.2em;
  }
}

.github-fork-ribbon-wrapper {
  display: none;
}
@media screen and (min-width: 800px) {
  /* "Fork me on GitHub" CSS ribbon based on
   * https://github.com/simonwhitaker/github-fork-ribbon-css
   */
  .github-fork-ribbon {
    position: absolute;
    padding: 2px 0;
    background-color: #a00;
    background-image: linear-gradient(to bottom, rgba(0, 0, 0, 0), rgba(0, 0, 0, 0.15));
    box-shadow: 0 2px 3px 0 rgba(0, 0, 0, 0.5);
    font: 700 12px "Helvetica Neue", Helvetica, Arial, sans-serif;

    pointer-events: auto;

    top: 38px;
    right: -45px;

    transform: rotate(45deg);
  }

  .github-fork-ribbon a[href],
  .github-fork-ribbon a[href]:hover {
    color: #fff;
    background-color: transparent;
    text-decoration: none;
    text-shadow: 0 -1px rgba(0, 0, 0, 0.5);
    text-align: center;

    width: 190px;
    line-height: 18px;

    display: inline-block;
    padding: 2px 0;

    border: 1.5px dotted #fff;
    border-color: rgba(255, 255, 255, 0.6);
  }

  .github-fork-ribbon-wrapper {
    display: block;
    width: 130px;
    height: 130px;
    position: absolute;
    overflow: hidden;
    top: 0; right: 0;
    z-index: 2;
    pointer-events: none;
  }
}
@media screen and (min-width: 1000px) {
  .github-fork-ribbon-wrapper {
    position: fixed;
  }
  /*]]>*/</style>
  <meta name="viewport" content="initial-scale=1.0">

<link href="rfc-local.css" rel="stylesheet" type="text/css">
<script type="application/javascript">async function addMetadata(){try{const e=document.styleSheets[0].cssRules;for(let t=0;t<e.length;t++)if(/#identifiers/.exec(e[t].selectorText)){const a=e[t].cssText.replace("#identifiers","#external-updates");document.styleSheets[0].insertRule(a,document.styleSheets[0].cssRules.length)}}catch(e){console.log(e)}const e=document.getElementById("external-metadata");if(e)try{var t,a="",o=function(e){const t=document.getElementsByTagName("meta");for(let a=0;a<t.length;a++)if(t[a].getAttribute("name")===e)return t[a].getAttribute("content");return""}("rfc.number");if(o){t="https://www.rfc-editor.org/rfc/rfc"+o+".json";try{const e=await fetch(t);a=await e.json()}catch(e){t=document.URL.indexOf("html")>=0?document.URL.replace(/html$/,"json"):document.URL+".json";const o=await fetch(t);a=await o.json()}}if(!a)return;e.style.display="block";const s="",d="https://datatracker.ietf.org/doc",n="https://datatracker.ietf.org/ipr/search",c="https://www.rfc-editor.org/info",l=a.doc_id.toLowerCase(),i=a.doc_id.slice(0,3).toLowerCase(),f=a.doc_id.slice(3).replace(/^0+/,""),u={status:"Status",obsoletes:"Obsoletes",obsoleted_by:"Obsoleted By",updates:"Updates",updated_by:"Updated By",see_also:"See Also",errata_url:"Errata"};let h="<dl style='overflow:hidden' id='external-updates'>";["status","obsoletes","obsoleted_by","updates","updated_by","see_also","errata_url"].forEach(e=>{if("status"==e){a[e]=a[e].toLowerCase();var t=a[e].split(" "),o=t.length,w="",p=1;for(let e=0;e<o;e++)p<o?w=w+r(t[e])+" ":w+=r(t[e]),p++;a[e]=w}else if("obsoletes"==e||"obsoleted_by"==e||"updates"==e||"updated_by"==e){var g,m="",b=1;g=a[e].length;for(let t=0;t<g;t++)a[e][t]&&(a[e][t]=String(a[e][t]).toLowerCase(),m=b<g?m+"<a href='"+s+"/rfc/".concat(a[e][t])+"'>"+a[e][t].slice(3)+"</a>, ":m+"<a href='"+s+"/rfc/".concat(a[e][t])+"'>"+a[e][t].slice(3)+"</a>",b++);a[e]=m}else if("see_also"==e){var y,L="",C=1;y=a[e].length;for(let t=0;t<y;t++)if(a[e][t]){a[e][t]=String(a[e][t]);var _=a[e][t].slice(0,3),v=a[e][t].slice(3).replace(/^0+/,"");L=C<y?"RFC"!=_?L+"<a href='"+s+"/info/"+_.toLowerCase().concat(v.toLowerCase())+"'>"+_+" "+v+"</a>, ":L+"<a href='"+s+"/info/"+_.toLowerCase().concat(v.toLowerCase())+"'>"+v+"</a>, ":"RFC"!=_?L+"<a href='"+s+"/info/"+_.toLowerCase().concat(v.toLowerCase())+"'>"+_+" "+v+"</a>":L+"<a href='"+s+"/info/"+_.toLowerCase().concat(v.toLowerCase())+"'>"+v+"</a>",C++}a[e]=L}else if("errata_url"==e){var R="";R=a[e]?R+"<a href='"+a[e]+"'>Errata exist</a> | <a href='"+d+"/"+l+"'>Datatracker</a>| <a href='"+n+"/?"+i+"="+f+"&submit="+i+"'>IPR</a> | <a href='"+c+"/"+l+"'>Info page</a>":"<a href='"+d+"/"+l+"'>Datatracker</a> | <a href='"+n+"/?"+i+"="+f+"&submit="+i+"'>IPR</a> | <a href='"+c+"/"+l+"'>Info page</a>",a[e]=R}""!=a[e]?"Errata"==u[e]?h+=`<dt>More info:</dt><dd>${a[e]}</dd>`:h+=`<dt>${u[e]}:</dt><dd>${a[e]}</dd>`:"Errata"==u[e]&&(h+=`<dt>More info:</dt><dd>${a[e]}</dd>`)}),h+="</dl>",e.innerHTML=h}catch(e){console.log(e)}else console.log("Could not locate metadata <div> element");function r(e){return e.charAt(0).toUpperCase()+e.slice(1)}}window.removeEventListener("load",addMetadata),window.addEventListener("load",addMetadata);</script>
</head>
<body>
<script src="metadata.min.js"></script>
<table class="ears">
<thead><tr>
<td class="left">Internet-Draft</td>
<td class="center">FLIC</td>
<td class="right">April 2021</td>
</tr></thead>
<tfoot><tr>
<td class="left">Tschudin, et al.</td>
<td class="center">Expires 26 October 2021</td>
<td class="right">[Page]</td>
</tr></tfoot>
</table>
<div id="external-metadata" class="document-information"></div>
<div id="internal-metadata" class="document-information">
<dl id="identifiers">
<dt class="label-workgroup">Workgroup:</dt>
<dd class="workgroup">ICNRG</dd>
<dt class="label-internet-draft">Internet-Draft:</dt>
<dd class="internet-draft">draft-tschudin-icnrg-flic-latest</dd>
<dt class="label-published">Published:</dt>
<dd class="published">
<time datetime="2021-04-24" class="published">24 April 2021</time>
    </dd>
<dt class="label-intended-status">Intended Status:</dt>
<dd class="intended-status">Experimental</dd>
<dt class="label-expires">Expires:</dt>
<dd class="expires"><time datetime="2021-10-26">26 October 2021</time></dd>
<dt class="label-authors">Authors:</dt>
<dd class="authors">
<div class="author">
      <div class="author-name">C. Tschudin</div>
<div class="org">University of Basel</div>
</div>
<div class="author">
      <div class="author-name">C.A. Wood</div>
<div class="org">University of California Irvine</div>
</div>
<div class="author">
      <div class="author-name">M.E. Mosko</div>
<div class="org">PARC, Inc.</div>
</div>
<div class="author">
      <div class="author-name">D. Oran</div>
<div class="org">Network Systems Research &amp; Design</div>
</div>
</dd>
</dl>
</div>
<h1 id="title">File-Like ICN Collections (FLIC)</h1>
<section id="section-abstract">
      <h2 id="abstract"><a href="#abstract" class="selfRef">Abstract</a></h2>
<p id="section-abstract-1">This document describes a bare bones "index table"-approach for
                organizing a set of ICN data objects into a large, File-Like
                ICN Collection (FLIC).
                
                At the core of this collection is a so called manifest which acts as
                the collection's root node. The manifest contains an index table with
                pointers, each pointer being a hash value pointing to either a final
                data block or another index table node.<a href="#section-abstract-1" class="pilcrow">¶</a></p>
</section>
<div id="status-of-memo">
<section id="section-boilerplate.1">
        <h2 id="name-status-of-this-memo">
<a href="#name-status-of-this-memo" class="section-name selfRef">Status of This Memo</a>
        </h2>
<p id="section-boilerplate.1-1">
        This Internet-Draft is submitted in full conformance with the
        provisions of BCP 78 and BCP 79.<a href="#section-boilerplate.1-1" class="pilcrow">¶</a></p>
<p id="section-boilerplate.1-2">
        Internet-Drafts are working documents of the Internet Engineering Task
        Force (IETF). Note that other groups may also distribute working
        documents as Internet-Drafts. The list of current Internet-Drafts is
        at <span><a href="https://datatracker.ietf.org/drafts/current/">https://datatracker.ietf.org/drafts/current/</a></span>.<a href="#section-boilerplate.1-2" class="pilcrow">¶</a></p>
<p id="section-boilerplate.1-3">
        Internet-Drafts are draft documents valid for a maximum of six months
        and may be updated, replaced, or obsoleted by other documents at any
        time. It is inappropriate to use Internet-Drafts as reference
        material or to cite them other than as "work in progress."<a href="#section-boilerplate.1-3" class="pilcrow">¶</a></p>
<p id="section-boilerplate.1-4">
        This Internet-Draft will expire on 26 October 2021.<a href="#section-boilerplate.1-4" class="pilcrow">¶</a></p>
</section>
</div>
<div id="copyright">
<section id="section-boilerplate.2">
        <h2 id="name-copyright-notice">
<a href="#name-copyright-notice" class="section-name selfRef">Copyright Notice</a>
        </h2>
<p id="section-boilerplate.2-1">
            Copyright (c) 2021 IETF Trust and the persons identified as the
            document authors. All rights reserved.<a href="#section-boilerplate.2-1" class="pilcrow">¶</a></p>
<p id="section-boilerplate.2-2">
            This document is subject to BCP 78 and the IETF Trust's Legal
            Provisions Relating to IETF Documents
            (<span><a href="https://trustee.ietf.org/license-info">https://trustee.ietf.org/license-info</a></span>) in effect on the date of
            publication of this document. Please review these documents
            carefully, as they describe your rights and restrictions with
            respect to this document. Code Components extracted from this
            document must include Simplified BSD License text as described in
            Section 4.e of the Trust Legal Provisions and are provided without
            warranty as described in the Simplified BSD License.<a href="#section-boilerplate.2-2" class="pilcrow">¶</a></p>
</section>
</div>
<div id="toc">
<section id="section-toc.1">
        <a href="#" onclick="scroll(0,0)" class="toplink">▲</a><h2 id="name-table-of-contents">
<a href="#name-table-of-contents" class="section-name selfRef">Table of Contents</a>
        </h2>
<nav class="toc"><ul class="toc compact ulEmpty">
<li class="toc compact ulEmpty" id="section-toc.1-1.1">
            <p id="section-toc.1-1.1.1" class="keepWithNext"><a href="#section-1" class="xref">1</a>.  <a href="#name-introduction" class="xref">Introduction</a></p>
<ul class="toc compact ulEmpty">
<li class="toc compact ulEmpty" id="section-toc.1-1.1.2.1">
                <p id="section-toc.1-1.1.2.1.1" class="keepWithNext"><a href="#section-1.1" class="xref">1.1</a>.  <a href="#name-requirements-language" class="xref">Requirements Language</a></p>
</li>
            </ul>
</li>
          <li class="toc compact ulEmpty" id="section-toc.1-1.2">
            <p id="section-toc.1-1.2.1" class="keepWithNext"><a href="#section-2" class="xref">2</a>.  <a href="#name-design-goals" class="xref">Design Goals</a></p>
</li>
          <li class="toc compact ulEmpty" id="section-toc.1-1.3">
            <p id="section-toc.1-1.3.1"><a href="#section-3" class="xref">3</a>.  <a href="#name-flic-structure" class="xref">FLIC Structure</a></p>
<ul class="toc compact ulEmpty">
<li class="toc compact ulEmpty" id="section-toc.1-1.3.2.1">
                <p id="section-toc.1-1.3.2.1.1"><a href="#section-3.1" class="xref">3.1</a>.  <a href="#name-terminology" class="xref">Terminology</a></p>
</li>
              <li class="toc compact ulEmpty" id="section-toc.1-1.3.2.2">
                <p id="section-toc.1-1.3.2.2.1"><a href="#section-3.2" class="xref">3.2</a>.  <a href="#name-locators" class="xref">Locators</a></p>
</li>
              <li class="toc compact ulEmpty" id="section-toc.1-1.3.2.3">
                <p id="section-toc.1-1.3.2.3.1"><a href="#section-3.3" class="xref">3.3</a>.  <a href="#name-namespaces" class="xref">Namespaces</a></p>
</li>
              <li class="toc compact ulEmpty" id="section-toc.1-1.3.2.4">
                <p id="section-toc.1-1.3.2.4.1"><a href="#section-3.4" class="xref">3.4</a>.  <a href="#name-manifest-metadata" class="xref">Manifest Metadata</a></p>
</li>
              <li class="toc compact ulEmpty" id="section-toc.1-1.3.2.5">
                <p id="section-toc.1-1.3.2.5.1"><a href="#section-3.5" class="xref">3.5</a>.  <a href="#name-pointer-annotations" class="xref">Pointer Annotations</a></p>
</li>
              <li class="toc compact ulEmpty" id="section-toc.1-1.3.2.6">
                <p id="section-toc.1-1.3.2.6.1"><a href="#section-3.6" class="xref">3.6</a>.  <a href="#name-manifest-grammar-abnf" class="xref">Manifest Grammar (ABNF)</a></p>
</li>
              <li class="toc compact ulEmpty" id="section-toc.1-1.3.2.7">
                <p id="section-toc.1-1.3.2.7.1"><a href="#section-3.7" class="xref">3.7</a>.  <a href="#name-manifest-trees" class="xref">Manifest Trees</a></p>
<ul class="toc compact ulEmpty">
<li class="toc compact ulEmpty" id="section-toc.1-1.3.2.7.2.1">
                    <p id="section-toc.1-1.3.2.7.2.1.1"><a href="#section-3.7.1" class="xref">3.7.1</a>.  <a href="#name-traversal" class="xref">Traversal</a></p>
</li>
                </ul>
</li>
              <li class="toc compact ulEmpty" id="section-toc.1-1.3.2.8">
                <p id="section-toc.1-1.3.2.8.1"><a href="#section-3.8" class="xref">3.8</a>.  <a href="#name-manifest-encryption" class="xref">Manifest Encryption</a></p>
<ul class="toc compact ulEmpty">
<li class="toc compact ulEmpty" id="section-toc.1-1.3.2.8.2.1">
                    <p id="section-toc.1-1.3.2.8.2.1.1"><a href="#section-3.8.1" class="xref">3.8.1</a>.  <a href="#name-preshared-key-algorithm" class="xref">Preshared Key Algorithm</a></p>
</li>
                  <li class="toc compact ulEmpty" id="section-toc.1-1.3.2.8.2.2">
                    <p id="section-toc.1-1.3.2.8.2.2.1"><a href="#section-3.8.2" class="xref">3.8.2</a>.  <a href="#name-rsa-key-encapsulation" class="xref">RSA Key Encapsulation</a></p>
</li>
                  <li class="toc compact ulEmpty" id="section-toc.1-1.3.2.8.2.3">
                    <p id="section-toc.1-1.3.2.8.2.3.1"><a href="#section-3.8.3" class="xref">3.8.3</a>.  <a href="#name-rsa-kem-dem" class="xref">RSA KEM-DEM</a></p>
</li>
                </ul>
</li>
              <li class="toc compact ulEmpty" id="section-toc.1-1.3.2.9">
                <p id="section-toc.1-1.3.2.9.1"><a href="#section-3.9" class="xref">3.9</a>.  <a href="#name-protocol-encodings" class="xref">Protocol Encodings</a></p>
<ul class="toc compact ulEmpty">
<li class="toc compact ulEmpty" id="section-toc.1-1.3.2.9.2.1">
                    <p id="section-toc.1-1.3.2.9.2.1.1"><a href="#section-3.9.1" class="xref">3.9.1</a>.  <a href="#name-ccnx-encoding" class="xref">CCNx Encoding</a></p>
<ul class="toc compact ulEmpty">
<li class="toc compact ulEmpty" id="section-toc.1-1.3.2.9.2.1.2.1">
                        <p id="section-toc.1-1.3.2.9.2.1.2.1.1"><a href="#section-3.9.1.1" class="xref">3.9.1.1</a>.  <a href="#name-ccnx-hash-naming" class="xref">CCNx Hash Naming</a></p>
</li>
                      <li class="toc compact ulEmpty" id="section-toc.1-1.3.2.9.2.1.2.2">
                        <p id="section-toc.1-1.3.2.9.2.1.2.2.1"><a href="#section-3.9.1.2" class="xref">3.9.1.2</a>.  <a href="#name-ccnx-single-prefix" class="xref">CCNx Single Prefix</a></p>
</li>
                      <li class="toc compact ulEmpty" id="section-toc.1-1.3.2.9.2.1.2.3">
                        <p id="section-toc.1-1.3.2.9.2.1.2.3.1"><a href="#section-3.9.1.3" class="xref">3.9.1.3</a>.  <a href="#name-ccnx-segmented-prefix" class="xref">CCNx Segmented Prefix</a></p>
</li>
                      <li class="toc compact ulEmpty" id="section-toc.1-1.3.2.9.2.1.2.4">
                        <p id="section-toc.1-1.3.2.9.2.1.2.4.1"><a href="#section-3.9.1.4" class="xref">3.9.1.4</a>.  <a href="#name-ccnx-hybrid-schema" class="xref">CCNx Hybrid Schema</a></p>
</li>
                    </ul>
</li>
                  <li class="toc compact ulEmpty" id="section-toc.1-1.3.2.9.2.2">
                    <p id="section-toc.1-1.3.2.9.2.2.1"><a href="#section-3.9.2" class="xref">3.9.2</a>.  <a href="#name-ndn-encoding" class="xref">NDN Encoding</a></p>
<ul class="toc compact ulEmpty">
<li class="toc compact ulEmpty" id="section-toc.1-1.3.2.9.2.2.2.1">
                        <p id="section-toc.1-1.3.2.9.2.2.2.1.1"><a href="#section-3.9.2.1" class="xref">3.9.2.1</a>.  <a href="#name-ndn-hash-naming" class="xref">NDN Hash Naming</a></p>
</li>
                      <li class="toc compact ulEmpty" id="section-toc.1-1.3.2.9.2.2.2.2">
                        <p id="section-toc.1-1.3.2.9.2.2.2.2.1"><a href="#section-3.9.2.2" class="xref">3.9.2.2</a>.  <a href="#name-ndn-single-prefix" class="xref">NDN Single Prefix</a></p>
</li>
                      <li class="toc compact ulEmpty" id="section-toc.1-1.3.2.9.2.2.2.3">
                        <p id="section-toc.1-1.3.2.9.2.2.2.3.1"><a href="#section-3.9.2.3" class="xref">3.9.2.3</a>.  <a href="#name-ndn-segmented-prefix" class="xref">NDN Segmented Prefix</a></p>
</li>
                      <li class="toc compact ulEmpty" id="section-toc.1-1.3.2.9.2.2.2.4">
                        <p id="section-toc.1-1.3.2.9.2.2.2.4.1"><a href="#section-3.9.2.4" class="xref">3.9.2.4</a>.  <a href="#name-ndn-hybrid-schema" class="xref">NDN Hybrid Schema</a></p>
</li>
                    </ul>
</li>
                </ul>
</li>
              <li class="toc compact ulEmpty" id="section-toc.1-1.3.2.10">
                <p id="section-toc.1-1.3.2.10.1"><a href="#section-3.10" class="xref">3.10</a>. <a href="#name-example-structures" class="xref">Example Structures</a></p>
<ul class="toc compact ulEmpty">
<li class="toc compact ulEmpty" id="section-toc.1-1.3.2.10.2.1">
                    <p id="section-toc.1-1.3.2.10.2.1.1"><a href="#section-3.10.1" class="xref">3.10.1</a>.  <a href="#name-leaf-only-data" class="xref">Leaf-only data</a></p>
</li>
                  <li class="toc compact ulEmpty" id="section-toc.1-1.3.2.10.2.2">
                    <p id="section-toc.1-1.3.2.10.2.2.1"><a href="#section-3.10.2" class="xref">3.10.2</a>.  <a href="#name-linear" class="xref">Linear</a></p>
</li>
                </ul>
</li>
            </ul>
</li>
          <li class="toc compact ulEmpty" id="section-toc.1-1.4">
            <p id="section-toc.1-1.4.1"><a href="#section-4" class="xref">4</a>.  <a href="#name-iana-considerations" class="xref">IANA Considerations</a></p>
</li>
          <li class="toc compact ulEmpty" id="section-toc.1-1.5">
            <p id="section-toc.1-1.5.1"><a href="#section-5" class="xref">5</a>.  <a href="#name-security-considerations" class="xref">Security Considerations</a></p>
</li>
          <li class="toc compact ulEmpty" id="section-toc.1-1.6">
            <p id="section-toc.1-1.6.1"><a href="#section-6" class="xref">6</a>.  <a href="#name-appendix-a-building-trees" class="xref">Appendix A: Building Trees</a></p>
</li>
          <li class="toc compact ulEmpty" id="section-toc.1-1.7">
            <p id="section-toc.1-1.7.1"><a href="#section-7" class="xref">7</a>.  <a href="#name-references" class="xref">References</a></p>
<ul class="toc compact ulEmpty">
<li class="toc compact ulEmpty" id="section-toc.1-1.7.2.1">
                <p id="section-toc.1-1.7.2.1.1"><a href="#section-7.1" class="xref">7.1</a>.  <a href="#name-normative-references" class="xref">Normative References</a></p>
</li>
              <li class="toc compact ulEmpty" id="section-toc.1-1.7.2.2">
                <p id="section-toc.1-1.7.2.2.1"><a href="#section-7.2" class="xref">7.2</a>.  <a href="#name-informative-references" class="xref">Informative References</a></p>
</li>
            </ul>
</li>
          <li class="toc compact ulEmpty" id="section-toc.1-1.8">
            <p id="section-toc.1-1.8.1"><a href="#section-appendix.a" class="xref"></a><a href="#name-authors-addresses" class="xref">Authors' Addresses</a></p>
</li>
        </ul>
</nav>
</section>
</div>
<section id="section-1">
      <h2 id="name-introduction">
<a href="#section-1" class="section-number selfRef">1. </a><a href="#name-introduction" class="section-name selfRef">Introduction</a>
      </h2>
<p id="section-1-1">The purpose of a manifest is to concisely name the constiuent pieces of a larger object.
                A FLIC manifest does this by using a first manifest to name and cryptographically sign
                the data structure and then use more concise lists of hash-based names to indicate
                the constituent pieces.  This maintains strong security from a single signature.
                A Manifest entry gives one enough information to create an Interest for that entry,
                so it must specify the name, the hash digest, and if needed the locators (routing hints).<a href="#section-1-1" class="pilcrow">¶</a></p>
<p id="section-1-2">A key question is how one names the root manifest, the application data, and
                other subsequent manifests.  The question of namespaces is specific to the names
                of each Content Object (CCNx) or Data (NDN), and is separate from the question of
                Locators.
                FLIC allows one to use a first namespace for the manifests and a second namespace
                for the application data.  A given namespace may use one of three schemas:
                hash-based naming, single-prefix naming, or segmented naming.
                We describe the allowed methods in  <a href="#namespaces" class="xref">Section 3.3</a>.
                There are also
                particulars of how to encode the name schema in a given ICN protocol, which we
                describe in <a href="#encodings" class="xref">Section 3.9</a>.<a href="#section-1-2" class="pilcrow">¶</a></p>
<p id="section-1-3">Locators are routing hints to find a Content Object / Data.  They exist in both
                CCNx and NDN, though the specifics differ.  A FLIC manifest encodes locators the same
                for both ICN protocols, though they are encoded differently in the underlying protocol.  See <a href="#encodings" class="xref">Section 3.9</a> for encoding differences.<a href="#section-1-3" class="pilcrow">¶</a></p>
<p id="section-1-4">We follow the <span><a href="#RFC8569" class="xref">CCNx</a> [<a href="#RFC8569" class="xref">RFC8569</a>]</span> terminology where a
                Content Object is the data structure that holds application payload.
                It is made up of an optional Name, a PayloadType, a Payload, and
                an optional Signature.<a href="#section-1-4" class="pilcrow">¶</a></p>
<p id="section-1-5">FLIC has encodings for <span><a href="#CCNxEncoding" class="xref">CCNx encoding</a> (<a href="#CCNxEncoding" class="xref">Section 3.9.1</a>)</span>
                as per <span><a href="#RFC8609" class="xref">RFC 8609</a> [<a href="#RFC8609" class="xref">RFC8609</a>]</span> and for <span><a href="#NDNEncoding" class="xref">NDN</a> (<a href="#NDNEncoding" class="xref">Section 3.9.2</a>)</span>.<a href="#section-1-5" class="pilcrow">¶</a></p>
<p id="section-1-6">An example implementation in Python may be found at 
             <span>[<a href="#FLICImplementation" class="xref">FLICImplementation</a>]</span>.<a href="#section-1-6" class="pilcrow">¶</a></p>
<section id="section-1.1">
        <h3 id="name-requirements-language">
<a href="#section-1.1" class="section-number selfRef">1.1. </a><a href="#name-requirements-language" class="section-name selfRef">Requirements Language</a>
        </h3>
<p id="section-1.1-1">The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD
                    NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as
                    described in <span><a href="#RFC2119" class="xref">RFC 2119</a> [<a href="#RFC2119" class="xref">RFC2119</a>]</span>.<a href="#section-1.1-1" class="pilcrow">¶</a></p>
</section>
</section>
<div id="goals">
<section id="section-2">
      <h2 id="name-design-goals">
<a href="#section-2" class="section-number selfRef">2. </a><a href="#name-design-goals" class="section-name selfRef">Design Goals</a>
      </h2>
<p id="section-2-1">The preferred FLIC structure copies the proven UNIX inode concept
                of direct and indirect pointers, but without the specific structural forms of
                direct versus indirect.<a href="#section-2-1" class="pilcrow">¶</a></p>
<p id="section-2-2">In FLIC terms, a direct pointer links to application-level data, which is
                a Content Object with application data in the Payload.
                An indirect pointer links to a Content Object with a FLIC Manifest in the
                Payload.<a href="#section-2-2" class="pilcrow">¶</a></p>
<p id="section-2-3">Links in FLIC use hash-based naming of Content Objects, rather than inode
                block numbers.  Both CCNx and NDN support hash-based naming, though the
                details vary.  See <a href="#CCNxEncoding" class="xref">Section 3.9.1</a> and <a href="#NDNEncoding" class="xref">Section 3.9.2</a>.
                Another advantage of using hash-based naming is it permits block-level de-duplication of application data because two blocks with the
                same payload will have the same hash name.<a href="#section-2-3" class="pilcrow">¶</a></p>
<p id="section-2-4">Because FLIC uses hash-based naming, FLIC graphs are inherently acyclic.<a href="#section-2-4" class="pilcrow">¶</a></p>
<p id="section-2-5">The preferred FLIC structure includes a root manifest with a strong
                cryptographic signature and then strong hash names to other manifests
                (e.g. SHA256).  The advantage of this structure is the single signature
                in the root manifest covers the entire data structure no matter how many
                additional manifests are in the data structure.  Another advantage of
                this structure is it removes the need to use chunk (CCNx) or
                segment (NDN) name components for the subordinate manifests.<a href="#section-2-5" class="pilcrow">¶</a></p>
<p id="section-2-6">FLIC supports manifest encryption separate from application payload encryption.  It has
                a flexible encryption envelope to support various encryption algorithms and
                key discovery mechanisms.  The byte layout allows for in-place encryption
                and decryption.<a href="#section-2-6" class="pilcrow">¶</a></p>
<p id="section-2-7">A limitation of this approach is that one cannot construct a hash-based name
                for a child until one knows the payload of that child.  In practical terms,
                this means that one must have the complete application payload available
                at the time of manifest creation.<a href="#section-2-7" class="pilcrow">¶</a></p>
<p id="section-2-8">FLIC's design allows straightforward applications that just need to traverse a linear set of related objects to do so simply, but FLIC has two extensibility mechanisms that allow for more sophisticated uses: manifest metadata, and pointer annotations. These are described in <a href="#metadata" class="xref">Section 3.4</a> and <a href="#annotations" class="xref">Section 3.5</a> respectively.<a href="#section-2-8" class="pilcrow">¶</a></p>
</section>
</div>
<div id="structure">
<section id="section-3">
      <h2 id="name-flic-structure">
<a href="#section-3" class="section-number selfRef">3. </a><a href="#name-flic-structure" class="section-name selfRef">FLIC Structure</a>
      </h2>
<div id="Terminology">
<section id="section-3.1">
        <h3 id="name-terminology">
<a href="#section-3.1" class="section-number selfRef">3.1. </a><a href="#name-terminology" class="section-name selfRef">Terminology</a>
        </h3>
<span class="break"></span><dl class="dlParallel" id="section-3.1-1">
          <dt id="section-3.1-1.1">Data Object:</dt>
          <dd style="margin-left: 1.5em" id="section-3.1-1.2">a CCNx nameless Content Object that usually only has Payload. It might also have an ExpiryTime to limit the lifetime of the data.<a href="#section-3.1-1.2" class="pilcrow">¶</a>
</dd>
          <dd class="break"></dd>
<dt id="section-3.1-1.3">Direct Pointer:</dt>
          <dd style="margin-left: 1.5em" id="section-3.1-1.4">borrowed from inode terminology, it is a CCNx link
                        using a content object hash restriction and a locator name to point to a Data Object.<a href="#section-3.1-1.4" class="pilcrow">¶</a>
</dd>
          <dd class="break"></dd>
<dt id="section-3.1-1.5">Indirect Pointer:</dt>
          <dd style="margin-left: 1.5em" id="section-3.1-1.6">borrowed from inode terminology, it is a CCNx link using a content object hash restriction and a locator name to point to a manifest content object.<a href="#section-3.1-1.6" class="pilcrow">¶</a>
</dd>
          <dd class="break"></dd>
<dt id="section-3.1-1.7">Manifest:</dt>
          <dd style="margin-left: 1.5em" id="section-3.1-1.8">a CCNx ContentObject with PayloadType 'Manifest' and a Payload of the encoded manifest. A leaf manifest only has direct pointers. An internal manifest has a mixture of direct and indirect manifests.<a href="#section-3.1-1.8" class="pilcrow">¶</a>
</dd>
          <dd class="break"></dd>
<dt id="section-3.1-1.9">Leaf Manifest:</dt>
          <dd style="margin-left: 1.5em" id="section-3.1-1.10">all pointers are direct pointers.<a href="#section-3.1-1.10" class="pilcrow">¶</a>
</dd>
          <dd class="break"></dd>
<dt id="section-3.1-1.11">Internal Manifest:</dt>
          <dd style="margin-left: 1.5em" id="section-3.1-1.12">some or all pointers are indirect. The order and number of each is up to the manifest builder. By convention, all the direct manifests come first, then the indirect.<a href="#section-3.1-1.12" class="pilcrow">¶</a>
</dd>
          <dd class="break"></dd>
<dt id="section-3.1-1.13">Manifest Waste:</dt>
          <dd style="margin-left: 1.5em" id="section-3.1-1.14">a metric used to measure the amount of waste in a manifest tree. Waste is the number of unused pointers. For example, a leaf manifest might be able to hold 40 direct pointers, but only 30 of them are used, so the waste of this node is 10. Manifest tree waste is the sum of waste over all manifests in a tree.<a href="#section-3.1-1.14" class="pilcrow">¶</a>
</dd>
          <dd class="break"></dd>
<dt id="section-3.1-1.15">Root Manifest:</dt>
          <dd style="margin-left: 1.5em" id="section-3.1-1.16">A signed, named, manifest that points to nameless manifest nodes. This structure means that the internal tree structure of internal and leaf manifests have no names and thus may be located anywhere in a namespace, while the root manifest has a name to fetch it by.<a href="#section-3.1-1.16" class="pilcrow">¶</a>
</dd>
          <dd class="break"></dd>
<dt id="section-3.1-1.17">Top Manifest:</dt>
          <dd style="margin-left: 1.5em" id="section-3.1-1.18">A preferred manifest structure is to use a Root manifest that points to a single Internal manifest called the Top Manifest. The Top manifest the begins the structure used to organize manifests.<a href="#section-3.1-1.18" class="pilcrow">¶</a>
</dd>
          <dd class="break"></dd>
<dt id="section-3.1-1.19">Namespace:</dt>
          <dd style="margin-left: 1.5em" id="section-3.1-1.20">The prefix and object name that goes inside a Content Object. It may include typed name components specifying a version and/or chunk/segment number.<a href="#section-3.1-1.20" class="pilcrow">¶</a>
</dd>
          <dd class="break"></dd>
<dt id="section-3.1-1.21">Locator:</dt>
          <dd style="margin-left: 1.5em" id="section-3.1-1.22">A routing hint in an Interest used by forwarding to get the Interest to where it can be matched based on its Namespace-derived name.<a href="#section-3.1-1.22" class="pilcrow">¶</a>
</dd>
        <dd class="break"></dd>
</dl>
</section>
</div>
<div id="locators">
<section id="section-3.2">
        <h3 id="name-locators">
<a href="#section-3.2" class="section-number selfRef">3.2. </a><a href="#name-locators" class="section-name selfRef">Locators</a>
        </h3>
<p id="section-3.2-1">Locators are routing hints used by forwarders to get an Interest to a node in the network that can resolve the Interest's name.  In some naming conventions, the name might only be a hash-based name so the Locator is the only available routing information.<a href="#section-3.2-1" class="pilcrow">¶</a></p>
<p id="section-3.2-2">A manifest Node may define one or more Locator prefixes that can be used in the construction of Interests from the pointers in the manifest.  The Locators are inherited when walking a manifest tree, so they do not need to be defined everywhere.  It is RECOMMENDED that only the Root manifest contain Locators so that a single operation can update the locators.  One usecase when storing application payloads at different replicas is to replace the Root manifest with a new one that contains locators for the current replicas.<a href="#section-3.2-2" class="pilcrow">¶</a></p>
</section>
</div>
<div id="namespaces">
<section id="section-3.3">
        <h3 id="name-namespaces">
<a href="#section-3.3" class="section-number selfRef">3.3. </a><a href="#name-namespaces" class="section-name selfRef">Namespaces</a>
        </h3>
<p id="section-3.3-1">A FLIC manifest may define zero or more namespaces.  If none are defined, FLIC uses the default Hash Naming approach.  If using namespaces, typically there are two defined:                    one for the manifest namespace and one for the application data namespace.  If the two are the same, they can share a namepace.  There may be more than two namespaces.<a href="#section-3.3-1" class="pilcrow">¶</a></p>
<p id="section-3.3-2">A namespace follows a naming convention.  The naming convention governs how FLIC creates the ICN Name that goes in an Interest's Name and must match a Content Object / Data Name. The conventions are: (1) Hash Naming, (2) Single Prefix, and (3) Segmented Prefix. The default is to use Hash Naming.  Hash Naming does not include anything besides a hash name in the Interest's name and relies on the Locator to forward the Interest. Single Prefix uses the same name differntiated only by a Content Object's implicit hash. Segmented Prefix keeps a counter for the namespace, starting with 0, and increments it after each use of the namespace.<a href="#section-3.3-2" class="pilcrow">¶</a></p>
<p id="section-3.3-3">The namespace definitions may be inherited from the Root manifest or the Top manifest, or any prior manifest.  It is RECOMMENDED that the namespace definitions appear in the Root manifest so they can be updated by a single operation.  Because Segmented Prefix namespaces use a counter, it is RECOMMENDED to only define them in the Root manifest or Top manifest and not elsewhere, as it may confuse the counters.<a href="#section-3.3-3" class="pilcrow">¶</a></p>
<p id="section-3.3-4">In the NodeData, there may be zero or more NSDef contains. Each NSDef defines a namespace identifier (octet string) and its naming convention. For the Hash Naming convention, no further information is required. For the Single Prefix and Segmented Prefix conventions, the NSDef specifies the ICN Name prefix used by the namespace.<a href="#section-3.3-4" class="pilcrow">¶</a></p>
<p id="section-3.3-5">A HashGroup may have an NSRef container that indicates which namespace it is using, and by implication which naming convention and the corresponding prefix. If there is no NSRef, the hash group uses Hash Naming convention.<a href="#section-3.3-5" class="pilcrow">¶</a></p>
</section>
</div>
<div id="metadata">
<section id="section-3.4">
        <h3 id="name-manifest-metadata">
<a href="#section-3.4" class="section-number selfRef">3.4. </a><a href="#name-manifest-metadata" class="section-name selfRef">Manifest Metadata</a>
        </h3>
<p id="section-3.4-1">The FLIC Manifest may be extended by defining TLVs that apply to the Manifest as a whole, or alternatively, individually to every data object pointed to by the Manifest. This basic specification does not specify any, but metadata TLVs may be defined through additional RFCs or via Vendor TLVs.  FLIC uses a Vendor TLV structure similar to <span>[<a href="#RFC8609" class="xref">RFC8609</a>]</span> for vendor-specific annotations that require no standardization process.<a href="#section-3.4-1" class="pilcrow">¶</a></p>
<p id="section-3.4-2">For example, some applications may find it useful to allow specialized consumers such as <em>repositories</em> (for example <span>[<a href="#repository" class="xref">repository</a>]</span>) or enhanced forwarder caches to pre-place, or adaptively pre-fetch data in order to improve robustness of delay performance. We note in passing that FLICs use of separate namespaces for the Manifest and the underlying Data allows different encryption keys to be used, hence giving a element like a cache or repository access to the Manifest data does not as a side effect reveal the contents of the application data itself.<a href="#section-3.4-2" class="pilcrow">¶</a></p>
</section>
</div>
<div id="annotations">
<section id="section-3.5">
        <h3 id="name-pointer-annotations">
<a href="#section-3.5" class="section-number selfRef">3.5. </a><a href="#name-pointer-annotations" class="section-name selfRef">Pointer Annotations</a>
        </h3>
<p id="section-3.5-1">FLIC allows each manifest pointer to be annotated with extra data. Annotations allow applications to exploit metadata about each Data Object pointed to without having to first fetch the corresponding Content Object. This specification defines one such annotation. The <em>SizeAnnotation</em> specifies the number of application layer octets covered by the pointer.<a href="#section-3.5-1" class="pilcrow">¶</a></p>
<p id="section-3.5-2">An annotation may, for example, give hints about a preferred traversal order for fetching the data, or an importance/precedence indication to aid applications that do not require every content object pointed to in the manifest to be fetched. This can be very useful for real-time or streaming media applications that can perform error concealment when rendering the media.<a href="#section-3.5-2" class="pilcrow">¶</a></p>
<p id="section-3.5-3">Additional annotations may be defined through additional RFCs or via Vendor TLVs.  FLIC uses a Vendor TLV structure similar to <span>[<a href="#RFC8609" class="xref">RFC8609</a>]</span> for vendor-specific annotations that require no standardization process.<a href="#section-3.5-3" class="pilcrow">¶</a></p>
</section>
</div>
<div id="grammar">
<section id="section-3.6">
        <h3 id="name-manifest-grammar-abnf">
<a href="#section-3.6" class="section-number selfRef">3.6. </a><a href="#name-manifest-grammar-abnf" class="section-name selfRef">Manifest Grammar (ABNF)</a>
        </h3>
<p id="section-3.6-1">The manifest grammar is mostly independent of the transport ICN protocol. The TLV encoding therefore follows the corresponding ICN protocol, so for CCNx FLIC uses 2 octet length, 2 octet type and for NDN uses the 1/3/5 octet types and lengths.  There are also some differences in how one structures and resolves links. <span>[<a href="#RFC8569" class="xref">RFC8569</a>]</span> defines HashValue and Link for CCNx encodings. The NDN ImplicitSha256DigestComponent defines HashValue and NDN Delegation (from Link Object) defines Link for NDN. The <a href="#encodings" class="xref">Section 3.9</a> section below specifies these differences.<a href="#section-3.6-1" class="pilcrow">¶</a></p>
<p id="section-3.6-2">The basic structure of a FLIC manifest is a security context, a node, and an authentication tag.  The security context and authentication tag are not needed if the node is unencrypted.  A node is made up of a set of metadata, the NodeData, that applies to the entire node, and one or more HashGroups that contain pointers.<a href="#section-3.6-2" class="pilcrow">¶</a></p>
<p id="section-3.6-3">The NodeData element defines the namespaces used by the manifest. There may be multiple namespaces, depending on how one names subsequent  manifests or data objects.  Each HashGroup may reference a single namespace to control how one forms Interests from the HashGroup.  If one is using separate namespaces for manifests and application data, one needs at least two HashGroups.  For a manifest structure of "MMMDDD," (where M means manifest (indirect pointer) and D means data (direct pointer))
                    for example, one would have a first hash group for the child manifests with its namespace and a second HashGroup for the data pointers with the other namespace. If one used a structure like "MMMDDDMMM," then one would need three HashGroups.<a href="#section-3.6-3" class="pilcrow">¶</a></p>
<span id="name-flic-grammar"></span><div id="flicgrammar">
<figure id="figure-1">
          <div class="artwork art-text alignLeft" id="section-3.6-4.1">
<pre>
TYPE = 2OCTET / {1,3,5}OCTET ; As per CCNx or NDN TLV
LENGTH = 2OCTET / {1,3,5}OCTET ; As per CCNx or NDN TLV

Manifest = TYPE LENGTH [SecurityCtx] (EncryptedNode / Node) [AuthTag]

SecurityCtx = TYPE LENGTH AlgorithmCtx
AlgorithmCtx = PresharedKeyCtx / RsaKemCtx / RsaKemDemCtx
AuthTag = TYPE LENGTH *OCTET ; e.g. AEAD authentication tag
EncryptedNode = TYPE LENGTH *OCTET ; Encrypted Node

Node = TYPE LENGTH [NodeData] 1*HashGroup
NodeData = TYPE LENGTH [SubtreeSize] [SubtreeDigest] [Locators] 0*NSDef
SubtreeSize = TYPE LENGTH INTEGER
SubtreeDigest = TYPE LENGTH HashValue
NSDef = TYPE LENGTH NsId NsSchema
NsId = TYPE LENGTH INTEGER
NsSchema = HashSchema / SinglePrefixSchema / SegmentedPrefixSchema
HashSchema = TYPE 0
SinglePrefixSchema = TYPE LENGTH Name
SegmentedPrefixSchema = TYPE LENGTH Name

Locators = TYPE LENGTH 1*Link
HashValue = TYPE LENGTH *OCTET ; As per ICN Protocol
Link = TYPE LENGTH *OCTET ; As per ICN protocol

HashGroup = TYPE LENGTH [GroupData] (Ptrs / AnnotatedPtrs)
Ptrs = TYPE LENGTH *HashValue
AnnotatedPtrs = TYPE LENGTH *PointerBlock
PointerBlock = TYPE LENGTH *Annotation Ptr
Ptr = TYPE LENGTH HashValue

Annotation = SizeAnnotation / Vendor
SizeAnnotation = TYPE LENGTH Integer
Vendor = TYPE LENGTH PEN *OCTET

GroupData = TYPE LENGTH [LeafSize] [LeafDigest] [SubtreeSize] [SubtreeDigest] [NsId]
LeafSize = TYPE LENGTH INTEGER
LeafDigest = TYPE LENGTH HashValue

PresharedKeyCtx = TYPE LENGTH PresharedKeyData
PresharedKeyData = KeyNum IV Mode
KeyNum = TYPE LENGTH INTEGER
IV = TYPE LENGTH 1*OCTET
Mode = TYPE LENGTH (AES-GCM-128 / AES-GCM-256)

RsaKemCtx = 2 LENGTH RsaKemData
RsaKemData = KeyId IV Mode WrappedKey LocatorPrefix
KeyId = TYPE LENGTH HashValue; ID of Key Encryption Key
WrappedKey = TYPE LENGTH 1*OCTET
LocatorPrefix = TYPE LENGTH Link

RsaKemDemCtx = 3 LENGTH RsaKemDemData
RsaKemDemData = KeyId IV Mode WrappedKey LocatorPrefix
</pre>
</div>
<figcaption><a href="#figure-1" class="selfRef">Figure 1</a>:
<a href="#name-flic-grammar" class="selfRef">FLIC Grammar</a>
          </figcaption></figure>
</div>
<span class="break"></span><dl class="dlParallel" id="section-3.6-5">
          <dt id="section-3.6-5.1">SecurityCtx:</dt>
          <dd style="margin-left: 1.5em" id="section-3.6-5.2">information about how to decrypt an EncryptedNode. The structure will depend on the specific encryption algorithm.<a href="#section-3.6-5.2" class="pilcrow">¶</a>
</dd>
          <dd class="break"></dd>
<dt id="section-3.6-5.3">AlgorithmId:</dt>
          <dd style="margin-left: 1.5em" id="section-3.6-5.4">The ID of the encryption method (e.g. preshared key, a broadcast encryption scheme, etc.)<a href="#section-3.6-5.4" class="pilcrow">¶</a>
</dd>
          <dd class="break"></dd>
<dt id="section-3.6-5.5">AlgorithmData:</dt>
          <dd style="margin-left: 1.5em" id="section-3.6-5.6">The context for the encryption algorithm.<a href="#section-3.6-5.6" class="pilcrow">¶</a>
</dd>
          <dd class="break"></dd>
<dt id="section-3.6-5.7">EncryptedNode:</dt>
          <dd style="margin-left: 1.5em" id="section-3.6-5.8">An opaque octet string with an optional authentication tag (i.e. for AEAD authentication tag)<a href="#section-3.6-5.8" class="pilcrow">¶</a>
</dd>
          <dd class="break"></dd>
<dt id="section-3.6-5.9">Node:</dt>
          <dd style="margin-left: 1.5em" id="section-3.6-5.10">A plain-text manifest node. The structure allows for in-place encryption/decryption.<a href="#section-3.6-5.10" class="pilcrow">¶</a>
</dd>
          <dd class="break"></dd>
<dt id="section-3.6-5.11">NodeData:</dt>
          <dd style="margin-left: 1.5em" id="section-3.6-5.12">the metadata about the Manifest node<a href="#section-3.6-5.12" class="pilcrow">¶</a>
</dd>
          <dd class="break"></dd>
<dt id="section-3.6-5.13">SubtreeSize:</dt>
          <dd style="margin-left: 1.5em" id="section-3.6-5.14">The size of all application data at and below the Node or Group<a href="#section-3.6-5.14" class="pilcrow">¶</a>
</dd>
          <dd class="break"></dd>
<dt id="section-3.6-5.15">SubtreeDigest:</dt>
          <dd style="margin-left: 1.5em" id="section-3.6-5.16">The cryptographic digest of all application data at and below the Node or Group<a href="#section-3.6-5.16" class="pilcrow">¶</a>
</dd>
          <dd class="break"></dd>
<dt id="section-3.6-5.17">Locators:</dt>
          <dd style="margin-left: 1.5em" id="section-3.6-5.18">An array of routing hints to find the manifest components<a href="#section-3.6-5.18" class="pilcrow">¶</a>
</dd>
          <dd class="break"></dd>
<dt id="section-3.6-5.19">HashGroup:</dt>
          <dd style="margin-left: 1.5em" id="section-3.6-5.20">A set of child pointers and associated metadata<a href="#section-3.6-5.20" class="pilcrow">¶</a>
</dd>
          <dd class="break"></dd>
<dt id="section-3.6-5.21">Ptrs:</dt>
          <dd style="margin-left: 1.5em" id="section-3.6-5.22">A list of one or more Hash Values<a href="#section-3.6-5.22" class="pilcrow">¶</a>
</dd>
          <dd class="break"></dd>
<dt id="section-3.6-5.23">GroupData:</dt>
          <dd style="margin-left: 1.5em" id="section-3.6-5.24">Metadata that applies to a HashGroup<a href="#section-3.6-5.24" class="pilcrow">¶</a>
</dd>
          <dd class="break"></dd>
<dt id="section-3.6-5.25">LeafSize:</dt>
          <dd style="margin-left: 1.5em" id="section-3.6-5.26">Size of all application data immediately under the Group (i.e. via direct pointers)<a href="#section-3.6-5.26" class="pilcrow">¶</a>
</dd>
          <dd class="break"></dd>
<dt id="section-3.6-5.27">LeafDigest:</dt>
          <dd style="margin-left: 1.5em" id="section-3.6-5.28">Digest of all application data immediately under the Group<a href="#section-3.6-5.28" class="pilcrow">¶</a>
</dd>
          <dd class="break"></dd>
<dt id="section-3.6-5.29">Ptr:</dt>
          <dd style="margin-left: 1.5em" id="section-3.6-5.30">The ContentObjectHash of a child, which may be a data ContentObject (i.e. with Payload) or another Manifest Node.<a href="#section-3.6-5.30" class="pilcrow">¶</a>
</dd>
          <dd class="break"></dd>
<dt id="section-3.6-5.31"></dt>
          <dd style="margin-left: 1.5em" id="section-3.6-5.32"></dd>
          <dd class="break"></dd>
<dt id="section-3.6-5.33"></dt>
          <dd style="margin-left: 1.5em" id="section-3.6-5.34"></dd>
        <dd class="break"></dd>
</dl>
</section>
</div>
<div id="trees">
<section id="section-3.7">
        <h3 id="name-manifest-trees">
<a href="#section-3.7" class="section-number selfRef">3.7. </a><a href="#name-manifest-trees" class="section-name selfRef">Manifest Trees</a>
        </h3>
<div id="traversal">
<section id="section-3.7.1">
          <h4 id="name-traversal">
<a href="#section-3.7.1" class="section-number selfRef">3.7.1. </a><a href="#name-traversal" class="section-name selfRef">Traversal</a>
          </h4>
<p id="section-3.7.1-1">FLIC manifests use a pre-order traversal.  This means they are read top to bottom, left to right.
                        The algorithms in <a href="#pseudocode" class="xref">Figure 2</a> show the in-order forward traversal code
                        and the reverse-oder traversal code, which we use below to construct such a tree.
                        This document does not mandate how to build trees.  Appendix A provides a detailed example
                        of building inode-like trees.<a href="#section-3.7.1-1" class="pilcrow">¶</a></p>
<p id="section-3.7.1-2">If using Annotated Pointers, an annotation could influence the traversal order.<a href="#section-3.7.1-2" class="pilcrow">¶</a></p>
<span id="name-traversal-pseudocode"></span><div id="pseudocode">
<figure id="figure-2">
            <div class="artwork art-text alignLeft" id="section-3.7.1-3.1">
<pre>
preorder(node)
    if (node = null)
        return
    visit(node)
    for (i = 0, i &lt; node.child.length, i++)
        preorder(node.child[i])

reverse_preorder(node)
    if (node = null)
        return
    for (i = node.child.length - 1, i &gt;= 0, i-- )
    reverse_preorder(node.child[i])
        visit(node)
</pre>
</div>
<figcaption><a href="#figure-2" class="selfRef">Figure 2</a>:
<a href="#name-traversal-pseudocode" class="selfRef">Traversal Pseudocode</a>
            </figcaption></figure>
</div>
<p id="section-3.7.1-4">In terms of the FLIC grammar, one expands a node into its hash groups, visiting each
                        hash group in order.  In each hash group, one follows each pointer in order.
                        Figure <a href="#expansion" class="xref">Figure 3</a> shows how hash groups inside a manifest expand like
                        virtual children in the tree.  The in-order traversal is M0, HG1, M1, HG3, D0, D1, D2,
                        HG2, D3, D4.<a href="#section-3.7.1-4" class="pilcrow">¶</a></p>
<span id="name-node-expansion"></span><div id="expansion">
<figure id="figure-3">
            <div class="artwork art-text alignLeft" id="section-3.7.1-5.1">
<pre>
M0 ____
|      \
HG1    HG2
| \    |  \
M1 D2  D3  D4
|
HG3
|  \
D0 D1
</pre>
</div>
<figcaption><a href="#figure-3" class="selfRef">Figure 3</a>:
<a href="#name-node-expansion" class="selfRef">Node Expansion</a>
            </figcaption></figure>
</div>
<p id="section-3.7.1-6">Using the example manifest tree shown in Figure <a href="#leafonly" class="xref">Figure 9</a>, the in-order
                    traversal would be: Root, M0, M1, D0, D1, D2, M2, D3, D4, D5, M3, D6, D7, D8.<a href="#section-3.7.1-6" class="pilcrow">¶</a></p>
</section>
</div>
</section>
</div>
<div id="encryption">
<section id="section-3.8">
        <h3 id="name-manifest-encryption">
<a href="#section-3.8" class="section-number selfRef">3.8. </a><a href="#name-manifest-encryption" class="section-name selfRef">Manifest Encryption</a>
        </h3>
<p id="section-3.8-1">This document specifies three encryption methods.  The first is a preshared key algorithm, where
                    the parties are assumed to have the decryption keys already.  This is useful, for example, when
                    using a key agreement protocol such as CCNxKE.
                    The second is an RSA key encapsulation mechanisms (RsaKem).
                    The third is a standard RSA KEM-DEM mechanism that uses a shared group key (RsaKemDem).<a href="#section-3.8-1" class="pilcrow">¶</a></p>
<p id="section-3.8-2">For group key based encryption, RsaKem and RsaKemDem, this specification only details the pertinent aspects
                    of the encryption.  It does not specify aspects of a key manager which may or may not be used
                    as part of key distribution and management, nor does it specify the protocol between a key manager
                    and a publisher.  In it's simpliest form, the publisher could be the
                    key manager, so there is no extra protocol needed between the publisher and key manager.
                    This specification does describe how a consumer locates the appropriate keys.<a href="#section-3.8-2" class="pilcrow">¶</a></p>
<p id="section-3.8-3">While the preshared key algorithm is limited in use, the AES encryption mechanisms described apply
                    to the group key mechanisms too.  They group key mechanisms simply facilitate distribution of
                    the shared key without an on-line key agreement protocol like CCNxKE.<a href="#section-3.8-3" class="pilcrow">¶</a></p>
<p id="section-3.8-4">A fourth encryption mechanism based on elliptic curve key distribution is forthcoming.<a href="#section-3.8-4" class="pilcrow">¶</a></p>
<div id="preshared">
<section id="section-3.8.1">
          <h4 id="name-preshared-key-algorithm">
<a href="#section-3.8.1" class="section-number selfRef">3.8.1. </a><a href="#name-preshared-key-algorithm" class="section-name selfRef">Preshared Key Algorithm</a>
          </h4>
<p id="section-3.8.1-1">
                        The KeyNum identifies a key on the receiver. The key must be of the correct length of the Mode used.
                        If the key is longer, use the left bits. Many receivers many have the same key with the same KeyId.
                        A publisher creates a signed root manifest with a security context. A consumer must ensure that the
                        root manifest signer is the expected publisher for use with the pre-shared key, which may be shared
                        with many other consumers. The publisher may use either method 8.2.1 (deterministic IV) or 8.2.2
                        (RBG-based IV) [NIST 800-38D] for creating the IV.<a href="#section-3.8.1-1" class="pilcrow">¶</a></p>
<p id="section-3.8.1-2">
                        Each encrypted manifest node (root manifest or internal manifest) has a full security
                        context (KeyNum, IV, Mode). The AES-GCM decryption is independent for each manifest so
                        Manifest objects can be fetched and decrypted in any order. This design also ensures that
                        if a manifest tree points to the same subtree repeatedly, such as for deduplication, the
                        decryptions are all idempotent.<a href="#section-3.8.1-2" class="pilcrow">¶</a></p>
<p id="section-3.8.1-3">
                        The functions for authenticated encryption and authenticated decryption are as given in
                        Sections 7.1 and 7.2 of NIST 800-38D: GCM-AE_K(IV, P, A) and GCM-AD_K(IV, C, A, T).<a href="#section-3.8.1-3" class="pilcrow">¶</a></p>
<span id="name-preshared-key-encrypt"></span><div id="pskencrypt">
<figure id="figure-4">
            <div class="artwork art-text alignLeft" id="section-3.8.1-4.1">
<pre>
EncryptNode(SecurityCtx, Node, K, IV) -&gt; GCM-AE_K(IV, P, A) -&gt; (C, T)
    Node: The wire format of the Node (P)
    SecurityCtx: The wire format of the SecurityCtx as the Additional Authenticated Data (A)
    K: the pre-shared key (128 or 256 bits)
    IV: The initialization vector (usually 96 or 128 bits)
    C: The cipher text
    T: The authentication tag
</pre>
</div>
<figcaption><a href="#figure-4" class="selfRef">Figure 4</a>:
<a href="#name-preshared-key-encrypt" class="selfRef">Preshared Key Encrypt</a>
            </figcaption></figure>
</div>
<p id="section-3.8.1-5">The pair (C,T) is the OpaqueNode encoded as a TLV structure: (OpaqueNode (CipherText C) (AuthTag T)).<a href="#section-3.8.1-5" class="pilcrow">¶</a></p>
<span id="name-preshared-key-decrypt"></span><div id="pskdecrypt">
<figure id="figure-5">
            <div class="artwork art-text alignLeft" id="section-3.8.1-6.1">
<pre>
DecryptNode(SecurityCtx, C, T, K, IV) -&gt; GCM-AD_K (IV, C, A, T) -&gt; (Node, FailFlag)
Node: The wire format of the decrypted Node
FailFlag: Indicates authenticated decryption failure (true or false)
</pre>
</div>
<figcaption><a href="#figure-5" class="selfRef">Figure 5</a>:
<a href="#name-preshared-key-decrypt" class="selfRef">Preshared Key Decrypt</a>
            </figcaption></figure>
</div>
<p id="section-3.8.1-7">
                        If doing in-place decryption, the cipher text C will be enclosed in an EncryptedNode TLV value.
                        After decryption, change the TLV type to Node. The length should be the same. After decryption
                        the AuthTag is no longer needed. The TLV type should be changed to T_PAD and the value zeroed.
                        The SecurityCtx could be changed to T_PAD and zeroed or left as-is.<a href="#section-3.8.1-7" class="pilcrow">¶</a></p>
</section>
</div>
<div id="rsakem">
<section id="section-3.8.2">
          <h4 id="name-rsa-key-encapsulation">
<a href="#section-3.8.2" class="section-number selfRef">3.8.2. </a><a href="#name-rsa-key-encapsulation" class="section-name selfRef">RSA Key Encapsulation</a>
          </h4>
<p id="section-3.8.2-1">See also RFC 5990, NIST SP 800-56B Rev. 2 and
                        https://lists.w3.org/Archives/Public/public-xmlsec/2009May/att-0032/Key_Encapsulation.pdf<a href="#section-3.8.2-1" class="pilcrow">¶</a></p>
<p id="section-3.8.2-2">In this system, a key manager (KM) (which could be the publisher) creates a symmetric Content Encryption Key
                        (CEK) and a key wrapping pair with a Key Encryption Key (KEK) and Key Decryption Key (KDK).
                        Each publisher and consumer has its own public/private key pair, and the KM knows each publisher's
                        and consumer's identity and its public key (PK_x).<a href="#section-3.8.2-2" class="pilcrow">¶</a></p>
<p id="section-3.8.2-3">
                        We do not describe the publisher-key manager protocol to request a CEK. The publisher will obtain
                        the (CEK, E_KEK(Z), KeyId, Locator), where each element is: the content encryption key, the CEK
                        precursor, Z, encrypted with the KEK (an RSA operation), and the KeyId of the corresponding KDK,
                        and the Locator is the CCNx name prefix to fetch the KDK (see below). The precursor Z is chosen
                        randomly z &lt; n-1, where n is KEK's public modulus. Note that CEK = KDF(Z). Note that the publisher
                        does not see KEK or Z.<a href="#section-3.8.2-3" class="pilcrow">¶</a></p>
<p id="section-3.8.2-4">
                        We use HKDF (RFC 5869) for the KDF. CEK = HKDF-Expand(HKDF-Extract(0, Z), "CEK", KeyLen),
                        where KenLen is usually 32 bytes (256 bits).<a href="#section-3.8.2-4" class="pilcrow">¶</a></p>
<p id="section-3.8.2-5">In the ABNF grammar, the RsaKemData includes a KeyId, IV, Mode, WrappedKey, and LocatorPrefix.
                        The KeyId is the ID (sha256) of the KEK.  The IV and Mode are as per preshared key, and describe
                        how the manifest is encrypted with AES-GCM.  The WrappedKey is the AES key to decrypt the manifest.
                        The LocatorPrefix is used to construct an Interest to fetch the KDK.<a href="#section-3.8.2-5" class="pilcrow">¶</a></p>
<p id="section-3.8.2-6">
                        To fetch the KDK, a consumer with public key PK_c constructs an Interest with name
                        /LocatorPrefix/{KeyId}/{PK_c keyid} and a KeyIdRestriction of the KM's KeyId (from the LocatorPrefix Link).
                        It should receive back a signed Content Object with the KDK wrapped for the consumer, or a NAK from the KM.
                        The payload of the ContentObject will be RsaKemWrap(PK, KDK). The signed ContentObject must have a
                        KeyLocator to the KM's public key. The consumer will trust the KM's public key because the publisher,
                        whom the consumer trusts, relayed that KeyId inside its own signed Manifest.<a href="#section-3.8.2-6" class="pilcrow">¶</a></p>
<p id="section-3.8.2-7">
                        The signed Content Object should have an ExpiryTime, which may be shorter than the Manifest's, but
                        should not be substantially longer than the Manifest's ExpiryTime. The KM may decide how to handle the
                        Recommended Cache Time, or if caching of the response is even permissible. The KM may require on-line
                        fetching of the response via a CCNxKE encrypted transport tunnel.<a href="#section-3.8.2-7" class="pilcrow">¶</a></p>
<span id="name-rsa-kem-wrap"></span><div id="rsakemwrap">
<figure id="figure-6">
            <div class="artwork art-text alignLeft" id="section-3.8.2-8.1">
<pre>
RsaKemWrap(PK, K, KeyLen = 256):
    choose z &lt; n-1, where n is PK's public modulus
    encrypt c = z^e mod n
    prk = HKDF-Extract(0, Z)
    kek = HKDF-Expand(prk, "RsaKemWrap", KeyLen)
    WK = E_KEK(K) # [AES-WRAP, RFC 3394]
    output (c, WK)
</pre>
</div>
<figcaption><a href="#figure-6" class="selfRef">Figure 6</a>:
<a href="#name-rsa-kem-wrap" class="selfRef">RSA KEM Wrap</a>
            </figcaption></figure>
</div>
<p id="section-3.8.2-9">
                        A consumer must verify the signed content object's signature against the Key Manager's public key.
                        The consumer then unwraps the KDK from the Content Object's payload using RsaKemUnwrap().
                        The KeyLen is taken from the WrapMode parameter.<a href="#section-3.8.2-9" class="pilcrow">¶</a></p>
<span id="name-rsa-kem-unwrap"></span><div id="rsakemunwrap">
<figure id="figure-7">
            <div class="artwork art-text alignLeft" id="section-3.8.2-10.1">
<pre>
RsaKemUnwrap(SK, c, WK, KeyLen = 256):
    Using the consumers private key SK, decrypt Z from c.
    prk = HKDF-Extract(0, Z)
    kek = HKDF-Expand(prk, "RsaKemWrap", KeyLen)
    K = D_KEK(WK) # [AES-UNWRAP, RFC 33940]
    output K
</pre>
</div>
<figcaption><a href="#figure-7" class="selfRef">Figure 7</a>:
<a href="#name-rsa-kem-unwrap" class="selfRef">RSA KEM Unwrap</a>
            </figcaption></figure>
</div>
<p id="section-3.8.2-11">
                        The consumer then unwraps the CEK precursor by using the KDK to decrypt Z. It then derives CEK as above.
                        Manifest encryption and decryption proceed as with PresharedKey, but using the CEK.<a href="#section-3.8.2-11" class="pilcrow">¶</a></p>
</section>
</div>
<div id="rsakemdem">
<section id="section-3.8.3">
          <h4 id="name-rsa-kem-dem">
<a href="#section-3.8.3" class="section-number selfRef">3.8.3. </a><a href="#name-rsa-kem-dem" class="section-name selfRef">RSA KEM-DEM</a>
          </h4>
<p id="section-3.8.3-1">In this scheme a Key Manager (KM), who could be the publisher, creates a Key Encryption Key (KEK)
                        and Key Decryption Key (KDK) key pair.  The publisher obtains the KEK.  The KM distributes the
                        KDK to each group member by encrypting it under each member's public key.
                        To encrypt data, the publisher generates a symmetric Content Encryption Key (CEK), wraps it with
                        the KEK, then encrypts the manifest with the CEK.  It places the wrapped CEK in the manifest.<a href="#section-3.8.3-1" class="pilcrow">¶</a></p>
<p id="section-3.8.3-2">The KM communicates the KEK to the publisher through an unspecified means particular to the KM.<a href="#section-3.8.3-2" class="pilcrow">¶</a></p>
<p id="section-3.8.3-3">The KM distributes the KDK to each group member.  It uses a name /{km-prefix}/{publisher-prefix}/{KDK KeyId}/{member KeyId}
                        to publish the encrypted KDK under a member's public key.  It uses RSA-OAEP for the encryption.<a href="#section-3.8.3-3" class="pilcrow">¶</a></p>
<p id="section-3.8.3-4">The publisher creates a random symmetric CEK of an appropriate bit length.  It uses the KEK to
                        wrap the CEK using RSA-OAEP.  It places the wrapped key in the manifest's RsaKemDemData along with the KeyId set to
                        the KDK's KeyId and the KeyLocator prefix /{km-prefix}/{publisher-prefix}/.
                        Each member appends the KDK KeyId and their public key KeyId to the name to attemt to fetch the KDK.
                        When forming the Interest to fetch the key, a consumer should also use a KeyIdRestriction of the KM's KeyId,
                        which it can retrieve from the KeyLocator.<a href="#section-3.8.3-4" class="pilcrow">¶</a></p>
</section>
</div>
</section>
</div>
<div id="encodings">
<section id="section-3.9">
        <h3 id="name-protocol-encodings">
<a href="#section-3.9" class="section-number selfRef">3.9. </a><a href="#name-protocol-encodings" class="section-name selfRef">Protocol Encodings</a>
        </h3>
<div id="CCNxEncoding">
<section id="section-3.9.1">
          <h4 id="name-ccnx-encoding">
<a href="#section-3.9.1" class="section-number selfRef">3.9.1. </a><a href="#name-ccnx-encoding" class="section-name selfRef">CCNx Encoding</a>
          </h4>
<p id="section-3.9.1-1">In CCNx, all Manifest content objects use a PayloadType of T_PYLDTYPE_MANIFEST, while all
                        application data content objects use a PayloadType of T_PYLDTYPE_DATA.<a href="#section-3.9.1-1" class="pilcrow">¶</a></p>
<span id="name-ccnx-embedding-grammar"></span><div id="CCNxGrammer">
<figure id="figure-8">
            <div class="artwork art-text alignLeft" id="section-3.9.1-2.1">
<pre>
ManifestContentObject = TYPE LENGTH [Name] [ExpiryTime] PayloadType Payload
Name = TYPE LENGTH *OCTET ; As per RFC8569
ExpiryTime = TYPE LENGTH *OCTET ; As per RFC8569
PayloadType = TYPE LENGTH T_PYLDTYPE_MANIFEST ; Value TBD
Payload : TYPE LENGTH *OCTET ; the serialized Manifest object
</pre>
</div>
<figcaption><a href="#figure-8" class="selfRef">Figure 8</a>:
<a href="#name-ccnx-embedding-grammar" class="selfRef">CCNx Embedding Grammar</a>
            </figcaption></figure>
</div>
<div id="CCNxHashNaming">
<section id="section-3.9.1.1">
            <h5 id="name-ccnx-hash-naming">
<a href="#section-3.9.1.1" class="section-number selfRef">3.9.1.1. </a><a href="#name-ccnx-hash-naming" class="section-name selfRef">CCNx Hash Naming</a>
            </h5>
<p id="section-3.9.1.1-1">The Hash Naming namespace uses CCNx nameless content objects.<a href="#section-3.9.1.1-1" class="pilcrow">¶</a></p>
<p id="section-3.9.1.1-2">It proceeds as follows:<a href="#section-3.9.1.1-2" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-3.9.1.1-3.1">The Root Manifest content object has a name used to fetch the manifest. It is signed by the publisher.
                                It has a set of Locators used to fetch the remainder of the manifest.  It has a single HashPointer that
                                points to the Top Manifest.  It may also have cache control directives, such as ExpiryTime.<a href="#section-3.9.1.1-3.1" class="pilcrow">¶</a>
</li>
              <li class="normal" id="section-3.9.1.1-3.2">The Root Manifest has an NsDef that specifies HashSchema.  It's GroupData uses that NsId.
                                All internal and leaf manifests use the same GroupData NsId.  A Manifest Tree MAY omit the NsDef and
                                NsId elements and rely on the default being HashSchema.<a href="#section-3.9.1.1-3.2" class="pilcrow">¶</a>
</li>
              <li class="normal" id="section-3.9.1.1-3.3">The Top Manifest is a nameless CCNx content object.  It may have cache control directies.<a href="#section-3.9.1.1-3.3" class="pilcrow">¶</a>
</li>
              <li class="normal" id="section-3.9.1.1-3.4">Internal and Leaf manifests are nameless CCNx content objects, possibly with cache control directives.<a href="#section-3.9.1.1-3.4" class="pilcrow">¶</a>
</li>
              <li class="normal" id="section-3.9.1.1-3.5">The Data content objects are nameless CCNx content objects, possibly with cache control directives.<a href="#section-3.9.1.1-3.5" class="pilcrow">¶</a>
</li>
              <li class="normal" id="section-3.9.1.1-3.6">To form an Interest for a direct or indirect pointer, use a Name from one of the Locators and put the
                                    pointer HashValue into the ContentObjectHashRestriction.<a href="#section-3.9.1.1-3.6" class="pilcrow">¶</a>
</li>
            </ul>
</section>
</div>
<div id="CCNxSinglePrefix">
<section id="section-3.9.1.2">
            <h5 id="name-ccnx-single-prefix">
<a href="#section-3.9.1.2" class="section-number selfRef">3.9.1.2. </a><a href="#name-ccnx-single-prefix" class="section-name selfRef">CCNx Single Prefix</a>
            </h5>
<p id="section-3.9.1.2-1">The Single Prefix schema uses the same name in all Content Objects and distinguishes them via
                            their ContentObjectHash.  Note that in CCNx, using a SinglePrefix name means that we do not
                            use Locators.<a href="#section-3.9.1.2-1" class="pilcrow">¶</a></p>
<p id="section-3.9.1.2-2">It proceeds as follows:<a href="#section-3.9.1.2-2" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-3.9.1.2-3.1">The Root Manifest content object has a name used to fetch the manifest.  It is signed by the publisher.
                                    It has a set of Locators used to fetch the remainder of the manifest.  It has a single HashPointer that
                                    points to the Top Manifest.  It may also have cache control directives, such as ExpiryTime.<a href="#section-3.9.1.2-3.1" class="pilcrow">¶</a>
</li>
              <li class="normal" id="section-3.9.1.2-3.2">The Root Manifest has an NsDef that specifies SinglePrefix and the SinglePrefixSchema element specifies
                                    the SinglePrefixName.<a href="#section-3.9.1.2-3.2" class="pilcrow">¶</a>
</li>
              <li class="normal" id="section-3.9.1.2-3.3">The Top Manifest has the name SinglePrefixName.  It may have cache control directies.  It's GroupData
                                elements must have an NsId that references the NsDef.<a href="#section-3.9.1.2-3.3" class="pilcrow">¶</a>
</li>
              <li class="normal" id="section-3.9.1.2-3.4">An Internal or Leaf manifest has the name SinglePrefixName, possibly with cache control directives.
                                    It's GroupData elements must have an NsId that references the NsDef.<a href="#section-3.9.1.2-3.4" class="pilcrow">¶</a>
</li>
              <li class="normal" id="section-3.9.1.2-3.5">The Data content objects have the name SinglePrefixName, possibly with cache control directives.<a href="#section-3.9.1.2-3.5" class="pilcrow">¶</a>
</li>
              <li class="normal" id="section-3.9.1.2-3.6">To form an Interest for a direct or indirect pointer, use SinglePrefixName as the Name and put the
                                    pointer HashValue into the ContentObjectHashRestriction.<a href="#section-3.9.1.2-3.6" class="pilcrow">¶</a>
</li>
            </ul>
</section>
</div>
<div id="CCNxSegmentedPrefix">
<section id="section-3.9.1.3">
            <h5 id="name-ccnx-segmented-prefix">
<a href="#section-3.9.1.3" class="section-number selfRef">3.9.1.3. </a><a href="#name-ccnx-segmented-prefix" class="section-name selfRef">CCNx Segmented Prefix</a>
            </h5>
<p id="section-3.9.1.3-1">The Segmented Prefix schema uses a different name in all Content Objects and distinguishes them via
                            their ContentObjectHash.  Note that in CCNx, using a SegmentedPrefixSchema means that we do not
                            use Locators.
                            OPTIONAL: Use AnnotatedPointers
                            to indicate the segment number of each hash pointer to avoid needing to infer the segment numbers.<a href="#section-3.9.1.3-1" class="pilcrow">¶</a></p>
<p id="section-3.9.1.3-2">It proceeds as follows:<a href="#section-3.9.1.3-2" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-3.9.1.3-3.1">The Root Manifest content object has a name used to fetch the manifest.  It is signed by the publisher.
                                    It has a set of Locators used to fetch the remainder of the manifest.  It has a single HashPointer that
                                    points to the Top Manifest.  It may also have cache control directives, such as ExpiryTime.<a href="#section-3.9.1.3-3.1" class="pilcrow">¶</a>
</li>
              <li class="normal" id="section-3.9.1.3-3.2">The Root Manifest has an NsDef that specifies SegmentedPrefix and the SegmentedPrefixSchema element specifies
                                    the SegmentedPrefixName.<a href="#section-3.9.1.3-3.2" class="pilcrow">¶</a>
</li>
              <li class="normal" id="section-3.9.1.3-3.3">The publisher will track the chunk number of each content object within the NsId.
                                    Objects will be numbered in their traversal order.  Within each manifest, the name will be
                                    constructed from the SegmentedPrefixName plus a Chunk name component.<a href="#section-3.9.1.3-3.3" class="pilcrow">¶</a>
</li>
              <li class="normal" id="section-3.9.1.3-3.4">The Top Manifest has the name SegmentedPrefixName plus chunk number.  It may have cache control directies.  It's GroupData
                                    elements must have an NsId that references the NsDef.<a href="#section-3.9.1.3-3.4" class="pilcrow">¶</a>
</li>
              <li class="normal" id="section-3.9.1.3-3.5">An Internal or Leaf manifest has the name SegmentedPrefixName plus chunk number, possibly with cache control directives.
                                    It's GroupData elements must have an NsId that references the NsDef.<a href="#section-3.9.1.3-3.5" class="pilcrow">¶</a>
</li>
              <li class="normal" id="section-3.9.1.3-3.6">The Data content objects have the name SegmentedPrefixName plus chunk number, possibly with cache control directives.<a href="#section-3.9.1.3-3.6" class="pilcrow">¶</a>
</li>
              <li class="normal" id="section-3.9.1.3-3.7">To form an Interest for a direct or indirect pointer, use SegmentedPrefixName plus chunk number as the Name and put the
                                    pointer HashValue into the ContentObjectHashRestriction.  A consumer must track the chunk number in
                                    traversal order for each SegmentedPrefixSchema NsId.<a href="#section-3.9.1.3-3.7" class="pilcrow">¶</a>
</li>
            </ul>
</section>
</div>
<div id="CCNxHybrid">
<section id="section-3.9.1.4">
            <h5 id="name-ccnx-hybrid-schema">
<a href="#section-3.9.1.4" class="section-number selfRef">3.9.1.4. </a><a href="#name-ccnx-hybrid-schema" class="section-name selfRef">CCNx Hybrid Schema</a>
            </h5>
<p id="section-3.9.1.4-1">A manifest may use multiple schemas.  For example, the application payload in data content objects might use
                            SegmentedPrefix while the manifest content objects might use HashNaming.<a href="#section-3.9.1.4-1" class="pilcrow">¶</a></p>
<p id="section-3.9.1.4-2">The Root Manifest should specify an NsDef with a first NsId (say 1) as the HashNaming schema and a second
                            NsDef with a second NsId (say 2) as the SegmentedPrefix schema along with the SegmentedPrefixName.<a href="#section-3.9.1.4-2" class="pilcrow">¶</a></p>
<p id="section-3.9.1.4-3">Each manifest (Top, Internal, Leaf) uses two or more HashGroups, where eash HashGroup has only Direct (with
                            the second NsId) or Indirect (with the first NsId).  The number of hash groups will depend on how the
                            publisher wishes to interleave direct and indirect pointers.<a href="#section-3.9.1.4-3" class="pilcrow">¶</a></p>
<p id="section-3.9.1.4-4">Manifests and data objects are named as appropriate for their naming schema.<a href="#section-3.9.1.4-4" class="pilcrow">¶</a></p>
</section>
</div>
</section>
</div>
<div id="NDNEncoding">
<section id="section-3.9.2">
          <h4 id="name-ndn-encoding">
<a href="#section-3.9.2" class="section-number selfRef">3.9.2. </a><a href="#name-ndn-encoding" class="section-name selfRef">NDN Encoding</a>
          </h4>
<p id="section-3.9.2-1">In NDN, all Manifest Data objects use a ContentType of FLIC (1024), while all
                        application data content objects use a PayloadType of Blob.<a href="#section-3.9.2-1" class="pilcrow">¶</a></p>
<div id="NDNHashNaming">
<section id="section-3.9.2.1">
            <h5 id="name-ndn-hash-naming">
<a href="#section-3.9.2.1" class="section-number selfRef">3.9.2.1. </a><a href="#name-ndn-hash-naming" class="section-name selfRef">NDN Hash Naming</a>
            </h5>
<p id="section-3.9.2.1-1">In NDN Hash Naming, a Data Object has a 0-length name.  This means that an Interest will only have
                            an ImplicitDigest name component in it.  This method relies on using NDN ForwardingHints.<a href="#section-3.9.2.1-1" class="pilcrow">¶</a></p>
<p id="section-3.9.2.1-2">It proceeds as follows:<a href="#section-3.9.2.1-2" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-3.9.2.1-3.1">The Root Manifest Data has a name used to fetch the manifest.  It is signed by the publisher.
                                    It has a set of Locators used to fetch the remainder of the manifest.  It has a single HashPointer that
                                    points to the Top Manifest.  It may also have cache control directives.<a href="#section-3.9.2.1-3.1" class="pilcrow">¶</a>
</li>
              <li class="normal" id="section-3.9.2.1-3.2">The Root Manifest has an NsDef that specifies HashSchema.  It's GroupData uses that NsId.
                                    All internal and leaf manifests use the same GroupData NsId.  A Manifest Tree MAY omit the NsDef and
                                    NsId elements and rely on the default being HashSchema.<a href="#section-3.9.2.1-3.2" class="pilcrow">¶</a>
</li>
              <li class="normal" id="section-3.9.2.1-3.3">The Top Manifest has a 0-length Name.  It may have cache control directies.<a href="#section-3.9.2.1-3.3" class="pilcrow">¶</a>
</li>
              <li class="normal" id="section-3.9.2.1-3.4">Internal and Leaf manifests has a 0-length Name, possibly with cache control directives.<a href="#section-3.9.2.1-3.4" class="pilcrow">¶</a>
</li>
              <li class="normal" id="section-3.9.2.1-3.5">The application Data use a 0-length name, possibly with cache control directives.<a href="#section-3.9.2.1-3.5" class="pilcrow">¶</a>
</li>
              <li class="normal" id="section-3.9.2.1-3.6">To form an Interest for a direct or indirect pointer, the name is only the Implicit Digest name component
                                    derived from a pointer's HashValue.  The ForwardingHints come from the Locators.  In NDN, one may use
                                    one or more locators within a single Interest.<a href="#section-3.9.2.1-3.6" class="pilcrow">¶</a>
</li>
            </ul>
</section>
</div>
<div id="NDNSinglePrefix">
<section id="section-3.9.2.2">
            <h5 id="name-ndn-single-prefix">
<a href="#section-3.9.2.2" class="section-number selfRef">3.9.2.2. </a><a href="#name-ndn-single-prefix" class="section-name selfRef">NDN Single Prefix</a>
            </h5>
<p id="section-3.9.2.2-1">In Single Prefix, the Data name is a common prefix used between all objects in that namespace,
                            without a Segment or other counter.  They are distinguished via the Implicit Digest
                            name component.  The FLIC Locators go in the ForwardingHints.<a href="#section-3.9.2.2-1" class="pilcrow">¶</a></p>
<p id="section-3.9.2.2-2">It proceeds as follows:<a href="#section-3.9.2.2-2" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-3.9.2.2-3.1">The Root Manifest Data object has a name used to fetch the manifest.  It is signed by the publisher.
                                    It has a set of Locators used to fetch the remainder of the manifest.  It has a single HashPointer that
                                    points to the Top Manifest.  It may also have cache control directives.<a href="#section-3.9.2.2-3.1" class="pilcrow">¶</a>
</li>
              <li class="normal" id="section-3.9.2.2-3.2">The Root Manifest has an NsDef that specifies SinglePrefix and the SinglePrefixSchema element specifies
                                    the SinglePrefixName.<a href="#section-3.9.2.2-3.2" class="pilcrow">¶</a>
</li>
              <li class="normal" id="section-3.9.2.2-3.3">The Top Manifest has the name SinglePrefixName.  It may have cache control directies.  It's GroupData
                                    elements must have an NsId that references the NsDef.<a href="#section-3.9.2.2-3.3" class="pilcrow">¶</a>
</li>
              <li class="normal" id="section-3.9.2.2-3.4">An Internal or Leaf manifest has the name SinglePrefixName, possibly with cache control directives.
                                    It's GroupData elements must have an NsId that references the NsDef.<a href="#section-3.9.2.2-3.4" class="pilcrow">¶</a>
</li>
              <li class="normal" id="section-3.9.2.2-3.5">The Data content objects have the name SinglePrefixName, possibly with cache control directives.<a href="#section-3.9.2.2-3.5" class="pilcrow">¶</a>
</li>
              <li class="normal" id="section-3.9.2.2-3.6">To form an Interest for a direct or indirect pointer, use SinglePrefixName as the Name and append
                                    the pointer's HashValue into an ImplicitDigest name component.  Set the ForwardingHints from
                                    the FLIC locators.<a href="#section-3.9.2.2-3.6" class="pilcrow">¶</a>
</li>
            </ul>
</section>
</div>
<div id="NDNSegmentedPrefix">
<section id="section-3.9.2.3">
            <h5 id="name-ndn-segmented-prefix">
<a href="#section-3.9.2.3" class="section-number selfRef">3.9.2.3. </a><a href="#name-ndn-segmented-prefix" class="section-name selfRef">NDN Segmented Prefix</a>
            </h5>
<p id="section-3.9.2.3-1">In Segmented Prefix, the Data name is a common prefix plus a segment number, so each
                            manifest or application data object has a unique full name before the implicit digest.
                            This means the consumer must maintain a counter for each SegmentedPrefix namespace.
                            OPTIONAL: Use AnnotatedPointers
                            to indicate the segment number of each hash pointer to avoid needing to infer the segment numbers.<a href="#section-3.9.2.3-1" class="pilcrow">¶</a></p>
<p id="section-3.9.2.3-2">It proceeds as follows:<a href="#section-3.9.2.3-2" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-3.9.2.3-3.1">The Root Manifest Data object has a name used to fetch the manifest.  It is signed by the publisher.
                                    It has a set of Locators used to fetch the remainder of the manifest.  It has a single HashPointer that
                                    points to the Top Manifest.  It may also have cache control directives.<a href="#section-3.9.2.3-3.1" class="pilcrow">¶</a>
</li>
              <li class="normal" id="section-3.9.2.3-3.2">The Root Manifest has an NsDef that specifies SegmentedPrefix and the SegmentedPrefixSchema element specifies
                                    the SegmentedPrefixName.<a href="#section-3.9.2.3-3.2" class="pilcrow">¶</a>
</li>
              <li class="normal" id="section-3.9.2.3-3.3">The publisher will track the segment number of each Data object within a SegmentedPrefix NsId.
                                    Data will be numbered in their traversal order.  Within each manifest, the name will be
                                    constructed from the SegmentedPrefixName plus a Segment name component.<a href="#section-3.9.2.3-3.3" class="pilcrow">¶</a>
</li>
              <li class="normal" id="section-3.9.2.3-3.4">The Top Manifest has the name SegmentedPrefixName plus segment number.  It may have cache control directies.  It's GroupData
                                    elements must have an NsId that references the NsDef.<a href="#section-3.9.2.3-3.4" class="pilcrow">¶</a>
</li>
              <li class="normal" id="section-3.9.2.3-3.5">An Internal or Leaf manifest has the name SegmentedPrefixName plus segment number, possibly with cache control directives.
                                    It's GroupData elements must have an NsId that references the NsDef.<a href="#section-3.9.2.3-3.5" class="pilcrow">¶</a>
</li>
              <li class="normal" id="section-3.9.2.3-3.6">The Data content objects have the name SegmentedPrefixName plus chunk number, possibly with cache control directives.<a href="#section-3.9.2.3-3.6" class="pilcrow">¶</a>
</li>
              <li class="normal" id="section-3.9.2.3-3.7">To form an Interest for a direct or indirect pointer, use SegmentedPrefixName plus segment number as the Name and put the
                                    pointer HashValue into the ImplicitDigest name component.  A consumer must track the segment number in
                                    traversal order for each SegmentedPrefixSchema NsId.<a href="#section-3.9.2.3-3.7" class="pilcrow">¶</a>
</li>
            </ul>
</section>
</div>
<div id="NDNHybrid">
<section id="section-3.9.2.4">
            <h5 id="name-ndn-hybrid-schema">
<a href="#section-3.9.2.4" class="section-number selfRef">3.9.2.4. </a><a href="#name-ndn-hybrid-schema" class="section-name selfRef">NDN Hybrid Schema</a>
            </h5>
<p id="section-3.9.2.4-1">A manifest may use multiple schemas.  For example, the application payload in data content objects might use
                            SegmentedPrefix while the manifest content objects might use HashNaming.<a href="#section-3.9.2.4-1" class="pilcrow">¶</a></p>
<p id="section-3.9.2.4-2">The Root Manifest should specify an NsDef with a first NsId (say 1) as the HashNaming schema and a second
                            NsDef with a second NsId (say 2) as the SegmentedPrefix schema along with the SegmentedPrefixName.<a href="#section-3.9.2.4-2" class="pilcrow">¶</a></p>
<p id="section-3.9.2.4-3">Each manifest (Top, Internal, Leaf) uses two or more HashGroups, where eash HashGroup has only Direct (with
                            the second NsId) or Indirect (with the first NsId).  The number of hash groups will depend on how the
                            publisher wishes to interleave direct and indirect pointers.<a href="#section-3.9.2.4-3" class="pilcrow">¶</a></p>
<p id="section-3.9.2.4-4">Manifests and data objects are named as appropriate for their naming schema.<a href="#section-3.9.2.4-4" class="pilcrow">¶</a></p>
</section>
</div>
</section>
</div>
</section>
</div>
<section id="section-3.10">
        <h3 id="name-example-structures">
<a href="#section-3.10" class="section-number selfRef">3.10. </a><a href="#name-example-structures" class="section-name selfRef">Example Structures</a>
        </h3>
<section id="section-3.10.1">
          <h4 id="name-leaf-only-data">
<a href="#section-3.10.1" class="section-number selfRef">3.10.1. </a><a href="#name-leaf-only-data" class="section-name selfRef">Leaf-only data</a>
          </h4>
<span id="name-leaf-only-manifest-tree"></span><div id="leafonly">
<figure id="figure-9">
            <div class="artwork art-text alignLeft" id="section-3.10.1-1.1">
<pre>
           Root
            |
     ______ M0 _____
    /       |       \
   M1       M2       M3
 / | \    / | \    / | \
D0 D1 D2 D3 D4 D5 D6 D7 D8
</pre>
</div>
<figcaption><a href="#figure-9" class="selfRef">Figure 9</a>:
<a href="#name-leaf-only-manifest-tree" class="selfRef">Leaf-only manifest tree</a>
            </figcaption></figure>
</div>
</section>
<section id="section-3.10.2">
          <h4 id="name-linear">
<a href="#section-3.10.2" class="section-number selfRef">3.10.2. </a><a href="#name-linear" class="section-name selfRef">Linear</a>
          </h4>
<p id="section-3.10.2-1">Of special interest are "skewed trees" where a pointer to a manifest
                        may only appear as last pointer of (sub-) manifests. Such a tree
                        becomes a sequential list of manifests with a maximum of datapointers
                        per manifest packet. Beside the tree shape we also show this data
                        structure in form of packet content where D stands for a data pointer
                        and M is the hash of a manifest packet.<a href="#section-3.10.2-1" class="pilcrow">¶</a></p>
<div class="artwork art-text alignLeft" id="section-3.10.2-2">
<pre>
Root -&gt; M0 ----&gt; M1 ----&gt; ...
|-&gt;DDDD  |-&gt;DDDD
</pre><a href="#section-3.10.2-2" class="pilcrow">¶</a>
</div>
</section>
</section>
</section>
</div>
<div id="IANA">
<section id="section-4">
      <h2 id="name-iana-considerations">
<a href="#section-4" class="section-number selfRef">4. </a><a href="#name-iana-considerations" class="section-name selfRef">IANA Considerations</a>
      </h2>
<p id="section-4-1">TODO Need IANA actions:<a href="#section-4-1" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-4-2.1">Create a registry for Manifest Data and Annotation TLVs<a href="#section-4-2.1" class="pilcrow">¶</a>
</li>
        <li class="normal" id="section-4-2.2">Register the SizeAnnotation TLV<a href="#section-4-2.2" class="pilcrow">¶</a>
</li>
      </ul>
<p id="section-4-3">
            Also TODO: If this document is submitted as an official RG
                draft, this section must be updated to reflect the IANA registries described in <span>[<a href="#RFC8609" class="xref">RFC8609</a>]</span><a href="#section-4-3" class="pilcrow">¶</a></p>
</section>
</div>
<div id="Security">
<section id="section-5">
      <h2 id="name-security-considerations">
<a href="#section-5" class="section-number selfRef">5. </a><a href="#name-security-considerations" class="section-name selfRef">Security Considerations</a>
    </h2>
</section>
</div>
<div id="AppendixA">
<section id="section-6">
      <h2 id="name-appendix-a-building-trees">
<a href="#section-6" class="section-number selfRef">6. </a><a href="#name-appendix-a-building-trees" class="section-name selfRef">Appendix A: Building Trees</a>
      </h2>
<p id="section-6-1">This section describes one method to build trees.  It constructs a pre-order tree in a single pass
                of the application data, going from the tail to the beginning.
                This allows us to work up the right side of the tree in a single pass, then work down each left
                branch until we exhaust the data.  Using the reverse-order traversal, we create the right-most-child
                manifest, then its parent, then the indirect pointers of that parent, then the parent's direct pointers,
                then the parent of the parent (repeating). This process uses recursion,
                as it is the clearest way to show the code. A more optimized approach could do it in a true single pass.<a href="#section-6-1" class="pilcrow">¶</a></p>
<p id="section-6-2">
                Because we're building from the bottom up, we use the term 'level' to be the distance from the
                right-most child up. Level 0 is the bottom-most level of the tree, such as where node 7 is:<a href="#section-6-2" class="pilcrow">¶</a></p>
<div class="artwork art-text alignLeft" id="section-6-3">
<pre>
      1
  2      3
4  5    6  7
preorder: 1 2 4 5 3 6 7
reverse:  7 6 3 5 4 2 1
</pre><a href="#section-6-3" class="pilcrow">¶</a>
</div>
<p id="section-6-4">The Python-like pseudocode build_tree(data, n, k, m) algorithm creates a tree of n data objects.
                The data[] array is an array of Content Objects that hold application payload; the application data
                has already been packetized into n Content Object packets.
                An interior manifest node has k direct pointers and m indirect pointers.<a href="#section-6-4" class="pilcrow">¶</a></p>
<div class="artwork art-text alignLeft" id="section-6-5">
<pre>
build_tree(data[0..n-1], n, k, m)
    # data is an array of Content Objects (Data in NDN) with application payload.
    # n is the number of data items
    # k is the number of direct pointers per internal node
    # m is the number of indirect pointers per internal node

    segment = namedtuple('Segment', 'head tail')(0, n)
    level = 0

    # This bootstraps the process by creating the right most child manifest
    # A leaf manifest has no indirect pointers, so k+m are direct pointers
    root = leaf_manifest(data, segment, k + m)

    # Keep building subtrees until we're out of direct pointers
    while not segment.empty():
        level += 1
        root = bottom_up_preorder(data, segment, level, k, m, root)

    return root
</pre><a href="#section-6-5" class="pilcrow">¶</a>
</div>
<div class="artwork art-text alignLeft" id="section-6-6">
<pre>
bottom_up_preorder(data, segment, level, k, m, right_most_child=None)
    manifest = None
    if level == 0:
        assert right_most_child is None
        # build a leaf manifest with only direct pointers
        manifest = leaf_manifest(data, segment, k + m)
    else:
        # If the number of remaining direct pointers will fit in a leaf node, make one of those.
        # Otherwise, we need to be an interior node
        if right_most_child is None and segment.length() &lt;= k + m:
            manifest = leaf_manifest(data, segment, k+m)
        else:
            manifest = interior_manifest(data, segment, level, k, m, right_most_child)
    return manifest
</pre><a href="#section-6-6" class="pilcrow">¶</a>
</div>
<div class="artwork art-text alignLeft" id="section-6-7">
<pre>
leaf_manifest(data, segment, count)
    # At most count items, but never go before the head
    start = max(segment.head(), segment.tail() - count)
    manifest = Manifest(data[start:segment.tail])
    segment.tail -= segment.tail() - start
    return manifest
</pre><a href="#section-6-7" class="pilcrow">¶</a>
</div>
<div class="artwork art-text alignLeft" id="section-6-8">
<pre>
interior_manifest(data, segment, level, k, m, right_most_child)
    children = []
    if right_most_child is not None:
        children.append(right_most_child)

    interior_indirect(data, segment, level, k, m, children)
    interior_direct(data, segment, level, k, m, children)

    manifest = Manifest(children)
    return manifest, tail
</pre><a href="#section-6-8" class="pilcrow">¶</a>
</div>
<div class="artwork art-text alignLeft" id="section-6-9">
<pre>
interior_indirect(data, segment, level, k, m, children)
    # Reserve space at the head of the segment for this node's direct pointers before
    # descending to children.  We want the top of the tree packed.
    reserve_count = min(m, segment.tail - segment.head)
    segment.head += reserve_count

    while len(children) &lt; m and not segment.head == segment.tail:
        child = bottom_up_preorder(data, segment, level - 1, k, m)
        # prepend
        children.insert(0, child)

    # Pull back our reservation and put those pointers in our direct children
    segment.head -= reserve_count
</pre><a href="#section-6-9" class="pilcrow">¶</a>
</div>
<div class="artwork art-text alignLeft" id="section-6-10">
<pre>
interior_direct(data, segment, level, k, m, children)
    while len(children) &lt; k+m and not segment.head == segment.tail:
        pointer = data[segment.tail() - 1]
        children.insert(0, pointer)
        segment.tail -= 1
</pre><a href="#section-6-10" class="pilcrow">¶</a>
</div>
</section>
</div>
<section id="section-7">
      <h2 id="name-references">
<a href="#section-7" class="section-number selfRef">7. </a><a href="#name-references" class="section-name selfRef">References</a>
      </h2>
<section id="section-7.1">
        <h3 id="name-normative-references">
<a href="#section-7.1" class="section-number selfRef">7.1. </a><a href="#name-normative-references" class="section-name selfRef">Normative References</a>
        </h3>
<dl class="references">
<dt id="RFC2119">[RFC2119]</dt>
      <dd>
<span class="refAuthor">Bradner, S.</span>, <span class="refTitle">"Key words for use in RFCs to Indicate Requirement Levels"</span>, <span class="seriesInfo">BCP 14</span>, <span class="seriesInfo">RFC 2119</span>, <span class="seriesInfo">DOI 10.17487/RFC2119</span>, <time datetime="1997-03" class="refDate">March 1997</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc2119">https://www.rfc-editor.org/info/rfc2119</a>&gt;</span>. </dd>
<dd class="break"></dd>
</dl>
</section>
<section id="section-7.2">
        <h3 id="name-informative-references">
<a href="#section-7.2" class="section-number selfRef">7.2. </a><a href="#name-informative-references" class="section-name selfRef">Informative References</a>
        </h3>
<dl class="references">
<dt id="FLICImplementation">[FLICImplementation]</dt>
        <dd>
<span class="refAuthor">Mosko, M.</span>, <span class="refTitle">"FLIC Implementation in Python"</span>, <span>various</span>, <span>&lt;<a href="https://github.com/mmosko/ccnpy">https://github.com/mmosko/ccnpy</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="NDN">[NDN]</dt>
        <dd>
<span class="refTitle">"Named Data Networking"</span>, <span>various</span>, <span>&lt;<a href="https://named-data.net/project/execsummary/">https://named-data.net/project/execsummary/</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="NDNTLV">[NDNTLV]</dt>
        <dd>
<span class="refTitle">"NDN Packet Format Specification."</span>, <time datetime="2016" class="refDate">2016</time>, <span>&lt;<a href="http://named-data.net/doc/ndn-tlv/">http://named-data.net/doc/ndn-tlv/</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="repository">[repository]</dt>
        <dd>
<span class="refTitle">"Repo Protocol Specification"</span>, <span>Various</span>, <span>&lt;<a href="https://redmine.named-data.net/projects/repo-ng/wiki/Repo_Protocol_Specification">https://redmine.named-data.net/projects/repo-ng/wiki/Repo_Protocol_Specification</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC3552">[RFC3552]</dt>
        <dd>
<span class="refAuthor">Rescorla, E.</span> and <span class="refAuthor">B. Korver</span>, <span class="refTitle">"Guidelines for Writing RFC Text on Security Considerations"</span>, <span class="seriesInfo">BCP 72</span>, <span class="seriesInfo">RFC 3552</span>, <span class="seriesInfo">DOI 10.17487/RFC3552</span>, <time datetime="2003-07" class="refDate">July 2003</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc3552">https://www.rfc-editor.org/info/rfc3552</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC5226">[RFC5226]</dt>
        <dd>
<span class="refAuthor">Narten, T.</span> and <span class="refAuthor">H. Alvestrand</span>, <span class="refTitle">"Guidelines for Writing an IANA Considerations Section in RFCs"</span>, <span class="seriesInfo">RFC 5226</span>, <span class="seriesInfo">DOI 10.17487/RFC5226</span>, <time datetime="2008-05" class="refDate">May 2008</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc5226">https://www.rfc-editor.org/info/rfc5226</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC8569">[RFC8569]</dt>
        <dd>
<span class="refAuthor">Mosko, M.</span>, <span class="refAuthor">Solis, I.</span>, and <span class="refAuthor">C. Wood</span>, <span class="refTitle">"Content-Centric Networking (CCNx) Semantics"</span>, <span class="seriesInfo">RFC 8569</span>, <span class="seriesInfo">DOI 10.17487/RFC8569</span>, <time datetime="2019-07" class="refDate">July 2019</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc8569">https://www.rfc-editor.org/info/rfc8569</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC8609">[RFC8609]</dt>
      <dd>
<span class="refAuthor">Mosko, M.</span>, <span class="refAuthor">Solis, I.</span>, and <span class="refAuthor">C. Wood</span>, <span class="refTitle">"Content-Centric Networking (CCNx) Messages in TLV Format"</span>, <span class="seriesInfo">RFC 8609</span>, <span class="seriesInfo">DOI 10.17487/RFC8609</span>, <time datetime="2019-07" class="refDate">July 2019</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc8609">https://www.rfc-editor.org/info/rfc8609</a>&gt;</span>. </dd>
<dd class="break"></dd>
</dl>
</section>
</section>
<div id="authors-addresses">
<section id="section-appendix.a">
      <h2 id="name-authors-addresses">
<a href="#name-authors-addresses" class="section-name selfRef">Authors' Addresses</a>
      </h2>
<address class="vcard">
        <div dir="auto" class="left"><span class="fn nameRole">Christian Tschudin</span></div>
<div dir="auto" class="left"><span class="org">University of Basel</span></div>
<div class="email">
<span>Email:</span>
<a href="mailto:christian.tschudin@unibas.ch" class="email">christian.tschudin@unibas.ch</a>
</div>
</address>
<address class="vcard">
        <div dir="auto" class="left"><span class="fn nameRole">Christopher A. Wood</span></div>
<div dir="auto" class="left"><span class="org">University of California Irvine</span></div>
<div class="email">
<span>Email:</span>
<a href="mailto:woodc1@uci.edu" class="email">woodc1@uci.edu</a>
</div>
</address>
<address class="vcard">
        <div dir="auto" class="left"><span class="fn nameRole">Marc Mosko</span></div>
<div dir="auto" class="left"><span class="org">PARC, Inc.</span></div>
<div class="email">
<span>Email:</span>
<a href="mailto:marc.mosko@parc.com" class="email">marc.mosko@parc.com</a>
</div>
</address>
<address class="vcard">
        <div dir="auto" class="left"><span class="fn nameRole">David Oran</span></div>
<div dir="auto" class="left"><span class="org">Network Systems Research &amp; Design</span></div>
<div class="email">
<span>Email:</span>
<a href="mailto:daveoran@orandom.net" class="email">daveoran@orandom.net</a>
</div>
</address>
</section>
</div>
<script>const toc = document.getElementById("toc");
toc.querySelector("h2").addEventListener("click", e => {
  toc.classList.toggle("active");
});
toc.querySelector("nav").addEventListener("click", e => {
  toc.classList.remove("active");
});
</script>
</body>
</html>

